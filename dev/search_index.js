var documenterSearchIndex = {"docs":
[{"location":"justrelax-Testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"justrelax-Testing/","page":"Testing","title":"Testing","text":"The implemented solvers of JustRelax.jl can be easily used given the following environment setup.","category":"page"},{"location":"justrelax-Testing/","page":"Testing","title":"Testing","text":"# Example script for running the 2D Stokes solvers\nusing JustRelax\nusing Printf, LinearAlgebra, CairoMakie\n\n# setup ParallelStencil.jl environment\nmodel = PS_Setup(:cpu, Float64, 2)\nenvironment!(model)\n\n# choose benchmark\nbenchmark = :solcx\n\n# model resolution (number of gridpoints)\nnx, ny = 128, 128\n\n# :single for a single run model with nx, ny resolution\n# :multiple for grid sensitivy error plot\nruntype = :single\n\nif benchmark == :solcx\n    # include plotting and error related functions\n    include(\"solcx/SolCx.jl\") # need to call this again if we switch from gpu <-> cpu\n    \n    # viscosity contrast\n    ∆η = 1e6\n    \n    if runtype == :single\n        # run model\n        geometry, stokes, iters, ρ = solCx(∆η; nx=nx, ny=ny)\n    \n        # plot model output and error\n        f = plot_solCx_error(geometry, stokes, ∆η; cmap=:romaO)\n    elseif runtype == :multiple\n        f = multiple_solCx(; ∆η=∆η, nrange=6:10) # nx = ny = 2^(nrange)-1\n    end\nelseif ...\n(...)\nend","category":"page"},{"location":"parallelstencil/#[ParallelStencil.jl](https://github.com/omlins/ParallelStencil.jl)-API","page":"ParallelStencil","title":"ParallelStencil.jl API","text":"","category":"section"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"The following API is created using the docstrings avaliable within the ParallelStencil.jl package, and is included for convinience here for look-up purpose. Please refer to the official repository and ask the creator of the packages if anything is unclear.","category":"page"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"CurrentModule = ParallelStencil","category":"page"},{"location":"parallelstencil/","page":"ParallelStencil","title":"ParallelStencil","text":"Modules = [ParallelStencil]","category":"page"},{"location":"parallelstencil/#ParallelStencil.ParallelStencil","page":"ParallelStencil","title":"ParallelStencil.ParallelStencil","text":"Module ParallelStencil\n\nEnables domain scientists to write high-level code for parallel high-performance stencil computations that can be deployed on both GPUs and CPUs.\n\nGeneral overview and examples\n\nhttps://github.com/omlins/ParallelStencil.jl\n\nPrimary macros\n\n@init_parallel_stencil\n@parallel\n@hide_communication\n@zeros\n@ones\n@rand\n\nnote: Advanced\n@parallel_indices\n@parallel_async\n@synchronize\n\nMacros available for @parallel_indices kernels\n\n@ps_show\n@ps_println\n\nnote: Advanced\n@gridDim\n@blockIdx\n@blockDim\n@threadIdx\n@sync_threads\n@sharedMem\n\nSubmodules\n\nParallelStencil.FiniteDifferences1D\nParallelStencil.FiniteDifferences2D\nParallelStencil.FiniteDifferences3D\n\nModules generated in caller\n\nData\n\nTo see a description of a macro or module type ?<macroname> (including the @) or ?<modulename>, respectively.\n\n\n\n\n\n","category":"module"},{"location":"parallelstencil/#ParallelStencil.@blockDim-Tuple","page":"ParallelStencil","title":"ParallelStencil.@blockDim","text":"@blockDim()\n\nReturn the block size (or \"dimension\") in x, y and z dimension. The block size in a specific dimension is commonly retrieved directly as in this example in x dimension: @blockDim().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@blockIdx-Tuple","page":"ParallelStencil","title":"ParallelStencil.@blockIdx","text":"@blockIdx()\n\nReturn the block ID in x, y and z dimension within the grid. The block ID in a specific dimension is commonly retrieved directly as in this example in x dimension: @blockIdx().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@gridDim-Tuple","page":"ParallelStencil","title":"ParallelStencil.@gridDim","text":"@gridDim()\n\nReturn the grid size (or \"dimension\") in x, y and z dimension. The grid size in a specific dimension is commonly retrieved directly as in this example in x dimension: @gridDim().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@hide_communication-Tuple","page":"ParallelStencil","title":"ParallelStencil.@hide_communication","text":"@hide_communication boundary_width block\n\nnote: Advanced\n@hide_communication ranges_outer ranges_inner block\n\nHide the communication behind the computation within the code block.\n\nArguments\n\nboundary_width::Tuple{Integer,Integer,Integer} | Tuple{Integer,Integer} | Tuple{Integer}: width of the boundaries in each dimension. The boundaries must include (at least) all the data that is accessed in the communcation performed.\nblock: code block wich starts with exactly one @parallel call to perform computations, followed by code to set boundary conditions and to perform communication (as e.g. update_halo! from the package ImplicitGlobalGrid). The @parallel call to perform computations cannot contain any positional arguments (ranges, nblocks or nthreads) nor the stream keyword argument (stream=...). The code to set boundary conditions and to perform communication must only access the elements in the boundary ranges of the fields modified in the @parallel call; all elements can be acccessed from other fields. Moreover, this code must not include statements in array broadcasting notation, because they are always run on the default CUDA stream (for CUDA.jl < v2.0), which makes CUDA stream overlapping impossible. Instead, boundary region elements can, e.g., be accessed with @parallel calls passing a ranges argument that ensures that no threads mapping to elements outside of ranges_outer are launched. Note that these @parallel ranges calls cannot contain any other positional arguments (nblocks or nthreads) nor the stream keyword argument (stream=...).\n\nnote: Advanced\nranges_outer::Tuple with one or multiple ranges as required by the corresponding argument of @parallel: the ranges must together span (at least) all the data that is accessed in the communcation and boundary conditions performed.\nranges_inner::Tuple with one or multiple ranges as required by the corresponding argument of @parallel: the ranges must together span the data that is not included by ranges_outer.\n\nExamples\n\n@hide_communication (16, 2, 2) begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    update_halo!(Te2);\nend\n\n@hide_communication (16, 2) begin\n    @parallel diffusion2D_step!(Te2, Te, Ci, lam, dt, dx, dy);\n    update_halo!(Te2);\nend\n\n@hide_communication ranges_outer ranges_inner begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    update_halo!(Te2);\nend\n\n@parallel_indices (iy,iz) function bc_x(A)\n    A[  1, iy,  iz] = A[    2,   iy,   iz]\n    A[end, iy,  iz] = A[end-1,   iy,   iz]\n    return\nend\n@parallel_indices (ix,iz) function bc_y(A)\n    A[ ix,  1,  iz] = A[   ix,    2,   iz]\n    A[ ix,end,  iz] = A[   ix,end-1,   iz]\n    return\nend\n@parallel_indices (ix,iy) function bc_z(A)\n    A[ ix,  iy,  1] = A[   ix,   iy,    2]\n    A[ ix,  iy,end] = A[   ix,   iy,end-1]\n    return\nend\n@hide_communication (16, 2, 2) begin\n    @parallel diffusion3D_step!(Te2, Te, Ci, lam, dt, dx, dy, dz);\n    @parallel (1:size(Te,2), 1:size(Te,3)) bc_x(Te);\n    @parallel (1:size(Te,1), 1:size(Te,3)) bc_y(Te);\n    @parallel (1:size(Te,1), 1:size(Te,2)) bc_z(Te);\n    update_halo!(Te2);\nend\n\nnote: Developers note\nThe communcation should not perform any blocking operations to enable a maximal overlap of communication with computation.\n\nSee also: @parallel\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@init_parallel_stencil-Tuple{Any, Any, Any}","page":"ParallelStencil","title":"ParallelStencil.@init_parallel_stencil","text":"@init_parallel_stencil(package, numbertype, ndims)\n\nInitialize the package ParallelStencil, giving access to its main functionality. Creates a module Data in the module where @init_parallel_stencil is called from. The module Data contains the types Data.Number, Data.Array and Data.DeviceArray (type ?Data after calling @init_parallel_stencil to see the full description of the module).\n\nArguments\n\npackage::Module: the package used for parallelization (CUDA or Threads).\nnumbertype::DataType: the type of numbers used by @zeros, @ones and @rand and in all array types of module Data (e.g. Float32 or Float64). It is contained in Data.Number after @initparallelstencil.\nndims::Integer: the number of dimensions used for the stencil computations in the kernels (1, 2 or 3).\n\nSee also: Data\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ones-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ones","text":"@ones(args...)\n\nCall ones(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function ones is chosen to be compatible with the package for parallelization selected with @init_parallel_stencil (ones for Threads CUDA.ones for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel","text":"@parallel kernel\n\nDeclare the kernel parallel and containing stencil computations be performed with one of the submodules ParallelStencil.FiniteDifferences{1D|2D|3D} (or with a compatible custom module or set of macros).\n\nSee also: @init_parallel_stencil\n\n\n\n@parallel kernelcall\n\nnote: Advanced\n@parallel ranges kernelcall\n@parallel nblocks nthreads kernelcall\n@parallel ranges nblocks nthreads kernelcall\n@parallel (...) kwargs... kernelcall\n\nDeclare the kernelcall parallel. The kernel will automatically be called as required by the package for parallelization selected with @init_parallel_stencil. Synchronizes at the end of the call (if a stream is given via keyword arguments, then it synchronizes only this stream).\n\nArguments\n\nkernelcall: a call to a kernel that is declared parallel.\n\nnote: Advanced optional arguments\nranges::Tuple{UnitRange{},UnitRange{},UnitRange{}} | Tuple{UnitRange{},UnitRange{}} | Tuple{UnitRange{}} | UnitRange{}: the ranges of indices in each dimension for which computations must be performed.\nnblocks::Tuple{Integer,Integer,Integer}: the number of blocks to be used if the package CUDA was selected with @init_parallel_stencil.\nnthreads::Tuple{Integer,Integer,Integer}: the number of threads to be used if the package CUDA was selected with @init_parallel_stencil.\nkwargs...: keyword arguments to be passed further to CUDA (ignored for Threads).\n\nnote: Performance note\nKernel launch parameters are automatically defined with heuristics, where not defined with optional kernel arguments. For CUDA nthreads is whenever reasonable set to (32,8,1) and nblocks accordingly to ensure that enough threads are launched.\n\nSee also: @init_parallel_stencil\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel_async-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel_async","text":"@parallel_async kernelcall\n\nnote: Advanced\n@parallel_async ranges kernelcall\n@parallel_async nblocks nthreads kernelcall\n@parallel_async ranges nblocks nthreads kernelcall\n@parallel_async (...) kwargs... kernelcall\n\nDeclare the kernelcall parallel as with @parallel (see @parallel for more information); deactivates however automatic synchronization at the end of the call. Use @synchronize for synchronizing.\n\nnote: Performance note\n@parallelasync falls currently back to running synchronously if the package Threads was selected with [`@initparallel_stencil`](@ref).\n\nSee also: @synchronize, @parallel\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@parallel_indices-Tuple","page":"ParallelStencil","title":"ParallelStencil.@parallel_indices","text":"@parallel_indices indices kernel\n\nDeclare the kernel parallel and generate the given parallel indices inside the kernel using the package for parallelization selected with @init_parallel_stencil.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ps_println-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ps_println","text":"@ps_println(...)\n\nCall a macro analogue to Base.@println, compatible with the package for parallelization selected with @init_parallel_stencil (Base.@println for Threads and CUDA.@cuprintln for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@ps_show-Tuple","page":"ParallelStencil","title":"ParallelStencil.@ps_show","text":"@ps_show(...)\n\nCall a macro analogue to Base.@show, compatible with the package for parallelization selected with @init_parallel_stencil (Base.@show for Threads and CUDA.@cushow for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@rand-Tuple","page":"ParallelStencil","title":"ParallelStencil.@rand","text":"@rand(args...)\n\nCall rand(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function rand is chosen/implemented to be compatible with the package for parallelization selected with @init_parallel_stencil.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@reset_parallel_stencil-Tuple{}","page":"ParallelStencil","title":"ParallelStencil.@reset_parallel_stencil","text":"@reset_parallel_stencil()\n\nReset the ParallelStencil module.\n\nSee also: init_parallel_stencil\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@sharedMem-Tuple","page":"ParallelStencil","title":"ParallelStencil.@sharedMem","text":"@sharedMem(T, dims)\n\nCreate an array that is shared between the threads of a block (i.e. accessible only by the threads of a same block), with element type T and size specified by dims.\n\nnote: Note\nThe amount of shared memory needs to specified when launching the kernel (keyword argument shmem).\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@sync_threads-Tuple","page":"ParallelStencil","title":"ParallelStencil.@sync_threads","text":"@sync_threads()\n\nSynchronize the threads of the block: wait until all threads in the block have reached this point and all global and shared memory accesses made by these threads prior to the sync_threads() call are visible to all threads in the block.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@synchronize-Tuple","page":"ParallelStencil","title":"ParallelStencil.@synchronize","text":"@synchronize()\n\nSynchronize the GPU/CPU.\n\nSee also: @parallel_async\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@threadIdx-Tuple","page":"ParallelStencil","title":"ParallelStencil.@threadIdx","text":"@threadIdx()\n\nReturn the thread ID in x, y and z dimension within the block. The thread ID in a specific dimension is commonly retrieved directly as in this example in x dimension: @threadIdx().x.\n\n\n\n\n\n","category":"macro"},{"location":"parallelstencil/#ParallelStencil.@zeros-Tuple","page":"ParallelStencil","title":"ParallelStencil.@zeros","text":"@zeros(args...)\n\nCall zeros(numbertype, args...), where numbertype is the datatype selected with @init_parallel_stencil and the function zeros is chosen to be compatible with the package for parallelization selected with @init_parallel_stencil (zeros for Threads and CUDA.zeros for CUDA).\n\n\n\n\n\n","category":"macro"},{"location":"benchmark-porosity-wave/#Porosity-Wave-Benchmark","page":"Porosity Wave","title":"Porosity Wave Benchmark","text":"","category":"section"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Using the decompaction weakening approach as in Raess et al.. We set up the benchmark for the porosity wave regime as limit of two-phase flow. The goal of this benchmark is to verify the reproducibility of the methodology as described here","category":"page"},{"location":"benchmark-porosity-wave/#Influence-of-spatial-resolution","page":"Porosity Wave","title":"Influence of spatial resolution","text":"","category":"section"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"We keep all the parameters identical as in Räss et al. 2019 and perform 5 experiments with increasing grid resolution.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"It is important to point out that the spatial resolution plays a very important role in our simulation. We reported here a plot consisting of the final porosity distribution log_10(fracphiphi_0) of the 5 experiments.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: final states of five experiments)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"We notice the similarities between the last two experiments of the highest resolution and observed the evolved two-channel morphology during time evolution. However, the last experiment also deviates from previous results of lower resolutions that it does not show very significant evolution of secondary channels and it shows the unique \"merging\" effect of the two-channel flow into a single channel when reaching 85% of the domain height.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: sensitivity analysis of spatial resolution)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"We identify the experiment 5 as an outlier in the figure above, where we further investigated the evolution of the normalized maximal porosity fracphi_textmaxphi_0 and the vertical distance of the point posessing the maximal value of porosity from initial pertubation Delta h (Phi_textmax). ","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"It is yet unclear whether this is a sign showing that the method converges or this blow-up phenomenon is brought by the accumulation of the numerical errors. The latter assumption is highly possible. With a total simulation time of t = 0.02, we performed 3296 iterations with a time step size of magnitude 10^-6, we could probably have reached machine precision3 by performing any arithmetic operations that involve it, which then can introduce roundoff errors,which are highly undesirable. Further investigations are needed by performing roundoff analysis and running simulations with even higher resolutions.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"In the following section we report the evolution of porosity waves in the performed five experiments.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Experiment 1: nx = 63, ny = 127","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# last 10 iterations\nit = 905, time = 2.181e-01 sec (@ T_eff = 5.60 GB/s) \nit = 906, time = 2.182e-01 sec (@ T_eff = 5.60 GB/s) \nit = 907, time = 2.212e-01 sec (@ T_eff = 5.50 GB/s) \nit = 908, time = 2.200e-01 sec (@ T_eff = 5.50 GB/s) \nit = 909, time = 2.192e-01 sec (@ T_eff = 5.60 GB/s) \nit = 910, time = 2.187e-01 sec (@ T_eff = 5.60 GB/s) \nit = 911, time = 2.170e-01 sec (@ T_eff = 5.60 GB/s) \nit = 912, time = 2.197e-01 sec (@ T_eff = 5.50 GB/s) \nit = 913, time = 2.193e-01 sec (@ T_eff = 5.60 GB/s) \nit = 914, time = 2.192e-01 sec (@ T_eff = 5.60 GB/s) \nit = 915, time = 1.819e-01 sec (@ T_eff = 5.60 GB/s)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: experiment01)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Experiment 2: nx = 127, ny = 255","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# last 10 iterations\nit = 1526, time = 5.757e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1527, time = 6.306e-01 sec (@ T_eff = 20.00 GB/s) \nit = 1528, time = 5.753e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1529, time = 5.386e-01 sec (@ T_eff = 21.00 GB/s) \nit = 1530, time = 5.775e-01 sec (@ T_eff = 20.00 GB/s) \nit = 1531, time = 5.663e-01 sec (@ T_eff = 20.00 GB/s) \nit = 1532, time = 5.366e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1533, time = 5.366e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1534, time = 5.767e-01 sec (@ T_eff = 20.00 GB/s) \nit = 1535, time = 5.330e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1536, time = 5.332e-01 sec (@ T_eff = 22.00 GB/s) ","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: experiment02)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Experiment 3: nx = 511, ny = 1023","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# last 10 iterations\nit = 2055, time = 2.922e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2056, time = 2.919e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2057, time = 2.917e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2058, time = 2.898e+00 sec (@ T_eff = 120.00 GB/s) \nit = 2059, time = 2.914e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2060, time = 2.915e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2061, time = 2.915e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2062, time = 2.919e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2063, time = 2.919e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2064, time = 2.918e+00 sec (@ T_eff = 110.00 GB/s) \nit = 2065, time = 2.896e+00 sec (@ T_eff = 120.00 GB/s) ","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: experiment03)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Experiment 4: nx = 1023, ny = 2047","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# last 10 iterations\nit = 1804, time = 9.881e+00 sec (@ T_eff = 140.00 GB/s) \nit = 1805, time = 9.914e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1806, time = 9.940e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1807, time = 9.911e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1808, time = 9.925e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1809, time = 9.913e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1810, time = 9.926e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1811, time = 9.924e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1812, time = 9.888e+00 sec (@ T_eff = 140.00 GB/s) \nit = 1813, time = 9.934e+00 sec (@ T_eff = 130.00 GB/s) \nit = 1814, time = 9.909e+00 sec (@ T_eff = 130.00 GB/s) ","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: experiment04)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Experiment 5: nx = 2047, ny = 4095","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# last 10 iterations\nit = 3286, time = 3.414e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3287, time = 3.411e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3288, time = 3.415e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3289, time = 3.412e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3290, time = 3.418e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3291, time = 3.413e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3292, time = 3.412e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3293, time = 3.408e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3294, time = 3.412e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3295, time = 3.409e+01 sec (@ T_eff = 160.00 GB/s) \nit = 3296, time = 3.412e+01 sec (@ T_eff = 160.00 GB/s) ","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"We also report the evolution of the porosity wave at different time steps in the following plot, reporting the normalized porosity log_10(fracphiphi_0) along with the colorbar used for the heatmap plotting. As we can see in the subplots, the evolution of the secondary channels is much less significant and are only visible in latter evolution phases as in (e), (f) subplots. The two-channel morphology also converges to a single-channel morphology at the end of the simulation unlike in previous four experiments.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: evolution of waves in highest resolution run)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"","category":"page"},{"location":"benchmark-porosity-wave/#Influence-of-compressibility-in-mass-conservation-equations","page":"Porosity Wave","title":"Influence of compressibility in mass conservation equations","text":"","category":"section"},{"location":"benchmark-porosity-wave/#Incompressible","page":"Porosity Wave","title":"Incompressible","text":"","category":"section"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Resulting animation of the code provided in the HydroMech2D.jl, which is the starting point of our implementation of the solver.","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"R=500, t=0.02","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: 2D wave)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"R=1.0, t=0.2","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: 2D wave)","category":"page"},{"location":"benchmark-porosity-wave/#Compressible","page":"Porosity Wave","title":"Compressible","text":"","category":"section"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"Followingly are the (truncated) results using the same model setup but with additional physical variables added for the compressible terms of the mass conservation equation","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"R=1000","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: 2D wave)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"R=500","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: 2D wave)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"R=1.0, t=0.03","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"(Image: 2D wave)","category":"page"},{"location":"benchmark-porosity-wave/","page":"Porosity Wave","title":"Porosity Wave","text":"# dimensionalized parameters used in (Dal Zilio et al. 2022)\nµ = 25G*Pa            # shear modulus\nKs = 50G*Pa           # bulk modulus\nβs = 2.5 10^-11 1/Pa  # solid compressibility\nβf = 4.0 10^-10 1/Pa  # fluid compressibility","category":"page"},{"location":"eigenvalue-problem/#Eigenvalue-Problem","page":"Eigenvalue Problem","title":"Eigenvalue Problem","text":"","category":"section"},{"location":"eigenvalue-problem/#Approximation-of-eigenvalues","page":"Eigenvalue Problem","title":"Approximation of eigenvalues","text":"","category":"section"},{"location":"eigenvalue-problem/#Gershgorin's-theorem","page":"Eigenvalue Problem","title":"Gershgorin's theorem","text":"","category":"section"},{"location":"eigenvalue-problem/","page":"Eigenvalue Problem","title":"Eigenvalue Problem","text":"Papadrakakis, 1981","category":"page"},{"location":"stiffness-of-pdes/#Stiffness-of-PDEs","page":"Stiffness of PDEs","title":"Stiffness of PDEs","text":"","category":"section"},{"location":"stiffness-of-pdes/#Approaches","page":"Stiffness of PDEs","title":"Approaches","text":"","category":"section"},{"location":"stiffness-of-pdes/#Operator-splitting","page":"Stiffness of PDEs","title":"Operator splitting","text":"","category":"section"},{"location":"stiffness-of-pdes/","page":"Stiffness of PDEs","title":"Stiffness of PDEs","text":"separate the system of PDEs into two parts\ni). Non-stiff part: first system which contains only hyperbolic operators\nii). Stiff part: second system which contains parabolic operators ('stiff'), solved independently from the first system at each time step.\ndifferent orders for various approaches\na). 1st order (Godunov-type)\nb). 2nd order (Strang splitting)\nc). other higher order splitting...\nconvergence requirements\nsmoothness of the solution of the system of PDEs","category":"page"},{"location":"methodology/#Methodology","page":"Methodology","title":"Methodology","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The methodology differs in the multiphysics coupling","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"i). Fully coupled modelassuming lithostatic total pressure gradient => decoupling of the fluid flow from shear deformation\nprediction of stresses and pressure distribution in the porous matrix (geomechanics)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Benifit 1: Total pressure does not follow a lithostatic gradient?\nBenifit 2: The shear deformation of the porous matrix is resolved?","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"a). Direct coupling (Industry-related simulator)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"fluid pressure is transferred to the geomechanical module, but the geomechanics do not impact the fluid pressure","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"b). Iterative coupling","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"iterative coupling of the fluid-flow solver to a geomechanical solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"c). Single solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"fully coupling of the fluid flow and the Stokes matrix flow within a single solver","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"ii). Decompaction weakening model  decompaction weakening while coupling Darcian and Stokes flows in 3-D","category":"page"},{"location":"methodology/#Decompaction-weakening-[Räss-et-al.-(2019)](https://doi.org/10.1093/gji/ggz239)","page":"Methodology","title":"Decompaction weakening Räss et al. (2019)","text":"","category":"section"},{"location":"methodology/#Motivation","page":"Methodology","title":"Motivation","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"study of various phenomena of porous fluids (fingering, veining, channeling and focussing)\nstructure: subseabed pipes (eg. on the Nigerian continental shelf and in the Norwegian North Sea) \nmay act as preferential fluid pathways. Understanding how these pipes are formed and evolved can help us to accurately constrain subsurface fluid flow","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"[] What is the delocalization of the patterns of the flow?","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Experiences:  flow patterns are localized, induced by fractures\nTheory:  using classical Darcian model, diffusive behavior is expected => leads to never-ending spreading and delocalization","category":"page"},{"location":"methodology/#What-is-the-decompaction-weakening?","page":"Methodology","title":"What is the decompaction weakening?","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"corresponds to high eta_d value","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The degree of the decompaction weakening can be quantitatively determined by the quotient of the compaction bulk viscosity eta_c and its decompaction counterpart eta_d.","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"R = fraceta_ceta_d","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Decompaction is significant R  1 => flow channeling\nwhen R=1 we have blob-like porosity waves","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The effective pressure P_e can be used to monitor the compaction within a certain region.","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Region in compaction P_e  0\nRegion in decompaction P_e  0","category":"page"},{"location":"methodology/#Mathematical-model","page":"Methodology","title":"Mathematical model","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Bulk viscosity","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"eta_phi = eta_c fracphi_0phi 1 + frac12 (frac1R - 1)(1 + tanh -fracp_elambda_p)","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"(Image: tanh_smoothing)","category":"page"},{"location":"methodology/#Numerical-experiment","page":"Methodology","title":"Numerical experiment","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Media:  fluid-saturated\nObjective:  observation of the flow patterns \nlocalized, delocalized?\nformation?\npropagation?","category":"page"},{"location":"methodology/#Numerical-methods","page":"Methodology","title":"Numerical methods","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"The PT-method used in Räss et al. added the non-linear residual terms f_v f_p^t f_p^f to 3 of the governing equations and aims to obtain the solution by minimizing the residuals iteratively within a pseudo-time loop","category":"page"},{"location":"methodology/#Results","page":"Methodology","title":"Results","text":"","category":"section"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"Decompaction weaknening","category":"page"},{"location":"methodology/","page":"Methodology","title":"Methodology","text":"3x-higher fluid-flow rate than the pure Darcy model","category":"page"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/#[GLMakie.jl](https://github.com/MakieOrg/Makie.jl)","page":"Visualization","title":"GLMakie.jl","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In case one is using Intel GPU and cannot make GLMakie to compile correctly, we may need to check if the needed libraries are linked correctly. More see this Github Issue","category":"page"},{"location":"performance/#Performance-comparison-for-mutable-and-immutable-struct-for-TwoPhaseFlowEquations","page":"Performance","title":"Performance comparison for mutable & immutable struct for TwoPhaseFlowEquations","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Since there is no significant difference between the usage of mutable/immutable class, after the application of Adapt.@adapt_structure. We use the mutable one for its flexibility.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# using immutable struct\nTime stepping: t_tot = 0.0005, dt = 1e-5\n┌ Warning: `object_info(obj::Union{File, Object})` is deprecated, use `API.h5o_get_info1(checkvalid(obj))` instead.\n│   caller = jldatatype(parent::JLD.JldFile, dtype::HDF5.Datatype) at jld_types.jl:690\n└ @ JLD ~/.julia/packages/JLD/S6t6A/src/jld_types.jl:690\n┌ Warning: `object_info(obj::Union{File, Object})` is deprecated, use `API.h5o_get_info1(checkvalid(obj))` instead.\n│   caller = typeindex(parent::JLD.JldFile, addr::UInt64) at jld_types.jl:812\n└ @ JLD ~/.julia/packages/JLD/S6t6A/src/jld_types.jl:812\nAnimation directory: ./viz2D_out/\nit = 1, time = 6.394e+00 sec (@ T_eff = 2.30 GB/s) \nit = 2, time = 2.201e-01 sec (@ T_eff = 11.00 GB/s) \nit = 3, time = 3.723e-01 sec (@ T_eff = 11.00 GB/s) \nit = 4, time = 3.689e-01 sec (@ T_eff = 8.90 GB/s) \nit = 5, time = 2.962e-01 sec (@ T_eff = 11.00 GB/s) \nit = 6, time = 3.768e-01 sec (@ T_eff = 11.00 GB/s) \nit = 7, time = 3.169e-01 sec (@ T_eff = 10.00 GB/s) \nit = 8, time = 3.818e-01 sec (@ T_eff = 11.00 GB/s) \nit = 9, time = 3.818e-01 sec (@ T_eff = 11.00 GB/s) \nit = 10, time = 3.811e-01 sec (@ T_eff = 11.00 GB/s) \nit = 11, time = 3.791e-01 sec (@ T_eff = 11.00 GB/s) \nit = 12, time = 3.820e-01 sec (@ T_eff = 11.00 GB/s) \nit = 13, time = 3.815e-01 sec (@ T_eff = 11.00 GB/s) \nit = 14, time = 3.698e-01 sec (@ T_eff = 11.00 GB/s) \nit = 15, time = 4.921e-01 sec (@ T_eff = 8.30 GB/s) \n[ Info: Saved animation to /home/wyou/misc/git-julia/HydroMech.jl/test/PorosityWave2D_incompressible.gif\nTest Summary:                                 | Pass  Total\nReference test: PorosityWave2D_incompressible |    5      5\n     Testing HydroMech tests passed ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# using mutable struct\nTime stepping: t_tot = 0.0005, dt = 1e-5\n┌ Warning: `object_info(obj::Union{File, Object})` is deprecated, use `API.h5o_get_info1(checkvalid(obj))` instead.\n│   caller = jldatatype(parent::JLD.JldFile, dtype::HDF5.Datatype) at jld_types.jl:690\n└ @ JLD ~/.julia/packages/JLD/S6t6A/src/jld_types.jl:690\n┌ Warning: `object_info(obj::Union{File, Object})` is deprecated, use `API.h5o_get_info1(checkvalid(obj))` instead.\n│   caller = typeindex(parent::JLD.JldFile, addr::UInt64) at jld_types.jl:812\n└ @ JLD ~/.julia/packages/JLD/S6t6A/src/jld_types.jl:812\nAnimation directory: ./viz2D_out/\nit = 1, time = 6.499e+00 sec (@ T_eff = 2.30 GB/s) \nit = 2, time = 2.220e-01 sec (@ T_eff = 11.00 GB/s) \nit = 3, time = 4.500e-01 sec (@ T_eff = 9.10 GB/s) \nit = 4, time = 2.955e-01 sec (@ T_eff = 11.00 GB/s) \nit = 5, time = 3.288e-01 sec (@ T_eff = 10.00 GB/s) \nit = 6, time = 3.869e-01 sec (@ T_eff = 11.00 GB/s) \nit = 7, time = 2.929e-01 sec (@ T_eff = 11.00 GB/s) \nit = 8, time = 3.841e-01 sec (@ T_eff = 11.00 GB/s) \nit = 9, time = 3.793e-01 sec (@ T_eff = 11.00 GB/s) \nit = 10, time = 3.788e-01 sec (@ T_eff = 11.00 GB/s) \nit = 11, time = 3.786e-01 sec (@ T_eff = 11.00 GB/s) \nit = 12, time = 3.795e-01 sec (@ T_eff = 11.00 GB/s) \nit = 13, time = 3.806e-01 sec (@ T_eff = 11.00 GB/s) \nit = 14, time = 3.796e-01 sec (@ T_eff = 11.00 GB/s) \nit = 15, time = 3.676e-01 sec (@ T_eff = 11.00 GB/s) \n[ Info: Saved animation to /home/wyou/misc/git-julia/HydroMech.jl/test/PorosityWave2D_incompressible.gif\nTest Summary:                                 | Pass  Total\nReference test: PorosityWave2D_incompressible |    5      5\n     Testing HydroMech tests passed ","category":"page"},{"location":"performance/#Benchmarking-for-GPUs-communication","page":"Performance","title":"Benchmarking for GPUs communication","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Goal: find out the best algorithm out of the tuned module","category":"page"},{"location":"performance/#Allreduce","page":"Performance","title":"Allreduce","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Firstly let's check which algorithms we can choose within the Open MPI source code","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"/* valid values for coll_tuned_allreduce_forced_algorithm */\nstatic const mca_base_var_enum_value_t allreduce_algorithms[] = {\n    {0, \"ignore\"},\n    {1, \"basic_linear\"},\n    {2, \"nonoverlapping\"},\n    {3, \"recursive_doubling\"},\n    {4, \"ring\"},\n    {5, \"segmented_ring\"},\n    {6, \"rabenseifner\"},\n    {0, NULL}\n};","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# firstly we run a benchmark of allreduce without specifying the wanted algorithm for allreduce\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                188.91            181.70            206.18        1000\n200000                340.12            326.85            367.30        1000\n400000                653.49            624.81            726.20        1000\n800000               1288.01           1237.06           1401.81        1000\n1600000              2500.98           2428.03           2685.87        1000\n3200000              4835.77           4681.47           5213.42        1000","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 0 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                188.91            181.73            204.79        1000\n200000                340.95            329.31            369.09        1000\n400000                653.47            625.27            726.33        1000\n800000               1287.86           1239.01           1416.19        1000\n1600000              2461.00           2388.66           2638.03        1000\n3200000              5091.87           4950.36           5581.74        1000\n\n\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 1 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                282.38            234.93            326.64        1000\n200000                531.14            437.42            618.39        1000\n400000               1785.82           1535.04           1995.28        1000\n800000               3124.20           2489.11           3370.94        1000\n1600000              6652.87           5687.09           7141.06        1000\n3200000             12774.89          11590.45          13431.57        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 2 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                235.63            187.88            279.57        1000\n200000                426.25            335.17            512.48        1000\n400000                928.40            724.02           1117.93        1000\n800000               2028.55           1418.95           2265.75        1000\n1600000              4333.00           3402.03           4806.96        1000\n3200000              8644.57           7506.92           9277.69        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 3 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                225.09            215.85            242.03        1000\n200000                420.43            401.66            455.58        1000\n400000                965.17            872.88           1046.27        1000\n800000               1840.35           1756.94           1925.51        1000\n1600000              3476.31           3229.06           3797.04        1000\n3200000              6619.64           6226.03           7271.89        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 4 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                190.26            180.55            204.62        1000\n200000                343.24            329.08            363.92        1000\n400000                643.02            615.56            681.21        1000\n800000               1240.29           1195.60           1309.38        1000\n1600000              2379.18           2324.61           2489.97        1000\n3200000              5013.59           4896.93           5356.24        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 5 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                189.72            181.01            202.38        1000\n200000                343.51            326.18            368.11        1000\n400000                644.34            616.66            683.36        1000\n800000               1242.93           1198.71           1309.88        1000\n1600000              2382.34           2321.88           2502.16        1000\n3200000              5042.74           4899.61           5478.59        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_allreduce_algorithm 6 osu_allreduce -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA Allreduce Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                189.19            182.10            205.89        1000\n200000                340.91            329.06            371.53        1000\n400000                650.34            620.61            727.53        1000\n800000               1295.93           1239.08           1422.91        1000\n1600000              2485.25           2386.89           2693.46        1000\n3200000              4825.75           4705.17           5159.61        1000","category":"page"},{"location":"performance/#All-to-all","page":"Performance","title":"All to all","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Same idea as above for allreduce, firstly let's check which algorithms we can choose within the Open MPI source code","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"/* valid values for coll_tuned_alltoall_forced_algorithm */\nstatic const mca_base_var_enum_value_t alltoall_algorithms[] = {\n    {0, \"ignore\"},\n    {1, \"linear\"},\n    {2, \"pairwise\"},\n    {3, \"modified_bruck\"},\n    {4, \"linear_sync\"},\n    {5, \"two_proc\"},\n    {0, NULL}\n};","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 0 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                425.38            415.71            438.20        1000\n200000                581.33            533.73            608.03        1000\n400000                984.05            863.74           1042.04        1000\n800000               1853.05           1626.89           1954.92        1000\n^[[A^[[B1600000              3679.50           3348.85           3887.69        1000\n3200000              7477.47           6683.02           7870.87        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 0 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                420.33            406.24            430.64        1000\n200000                577.81            526.10            607.41        1000\n400000               1000.56            905.46           1062.94        1000\n800000               1917.38           1825.38           1981.69        1000\n1600000              3655.49           3450.80           3819.48        1000\n3200000              7194.83           6974.15           7478.59        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 1 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                419.08            404.52            441.48        1000\n200000                572.08            523.91            601.56        1000\n400000               1014.65            931.97           1073.41        1000\n800000               1911.66           1782.75           1972.40        1000\n1600000              3651.50           3410.06           3797.36        1000\n3200000              7235.04           6925.96           7401.02        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 2 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                568.08            542.70            591.89        1000\n200000                751.72            699.47            797.65        1000\n400000               1122.81           1071.18           1180.94        1000\n800000               1882.45           1820.97           1953.62        1000\n1600000              3414.76           3294.48           3518.95        1000\n3200000              6453.58           6211.23           6598.42        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 3 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000              17079.06          14886.58          18710.19        1000\n200000              34372.18          30221.50          36966.10        1000\n^C^C[wyou@racklette1 ~]$ ^C\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 4 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n100000                424.61            414.48            434.69        1000\n200000                601.03            574.16            623.39        1000\n400000               1074.30            991.98           1134.93        1000\n800000               2026.54           1856.56           2126.15        1000\n1600000              3897.18           3565.51           4089.64        1000\n3200000              7654.23           6901.72           8030.77        1000\n[wyou@racklette1 ~]$ $(which mpirun) -x PATH=$PATH -x LD_LIBRARY_PATH=$LD_LIBRARY_PATH -n 8 --hostfile ./4nodes -npernode 640 -mca coll_tuned_use_dynamic_rules 1 -mca coll_tuned_alltoall_algorithm 5 osu_alltoall -f -m 100000:5242880 -i 1000 -M 50000000 -d cuda D D\n\n# OSU MPI-CUDA All-to-All Personalized Exchange Latency Test v5.9\n# Size       Avg Latency(us)   Min Latency(us)   Max Latency(us)  Iterations\n[racklette1:1216262] *** An error occurred in MPI_Alltoall\n[racklette1:1216262] *** reported by process [3756916737,2]\n[racklette1:1216262] *** on communicator MPI_COMM_WORLD\n[racklette1:1216262] *** MPI_ERR_UNSUPPORTED_OPERATION: operation not supported\n[racklette1:1216262] *** MPI_ERRORS_ARE_FATAL (processes in this communicator will now abort,\n[racklette1:1216262] ***    and potentially your MPI job)\n[racklette1:1216244] 7 more processes have sent help message help-mpi-errors.txt / mpi_errors_are_fatal\n[racklette1:1216244] Set MCA parameter \"orte_base_help_aggregate\" to 0 to see all help / error messages\n\n","category":"page"},{"location":"performance/#Improving-the-source-code","page":"Performance","title":"Improving the source code","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"# without visualization\nit = 1530, time = 5.027e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 4.839e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1532, time = 4.861e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1533, time = 5.011e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 4.852e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1535, time = 5.018e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 4.849e-01 sec (@ T_eff = 24.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# with visualization\nit = 1530, time = 5.132e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 5.105e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1532, time = 5.286e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1533, time = 5.123e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 5.308e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1535, time = 5.107e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 5.233e-01 sec (@ T_eff = 22.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"After some basic HPC-driven code improvement while making sure all the reference tests passed, the original 2D code has the following performance","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# without visualization\nit = 1530, time = 4.946e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1531, time = 5.352e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1532, time = 4.941e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1533, time = 4.940e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1534, time = 5.163e-01 sec (@ T_eff = 22.00 GB/s) \nit = 1535, time = 4.942e-01 sec (@ T_eff = 23.00 GB/s) \nit = 1536, time = 4.942e-01 sec (@ T_eff = 23.00 GB/s) ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# with visualization\nit = 1530, time = 4.619e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1531, time = 4.601e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1532, time = 4.899e-01 sec (@ T_eff = 24.00 GB/s) \nit = 1533, time = 4.594e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1534, time = 4.651e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1535, time = 4.665e-01 sec (@ T_eff = 25.00 GB/s) \nit = 1536, time = 4.837e-01 sec (@ T_eff = 24.00 GB/s) ","category":"page"},{"location":"performance/#Distributed-Computing","page":"Performance","title":"Distributed Computing","text":"","category":"section"},{"location":"performance/#Tutorial","page":"Performance","title":"Tutorial","text":"","category":"section"},{"location":"performance/#Simple-Performance-Estimation","page":"Performance","title":"Simple Performance Estimation","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"We can estimate the performance using the following metrics ","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"T_texteff = fracA_textefft_textit = frac2 D_u + D_kDelta t  textniter","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"TODO: add the example of the effective memory","category":"page"},{"location":"performance/#Parallelizing-a-serial-code","page":"Performance","title":"Parallelizing a serial code","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 1: Precompute scalars, remove divisions","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# instead of division, we precompute the fractions to be multipled on\n_β_dτ_D     = 1. /β_dτ_D","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 2: Remove element-wise operators and use loops instead for updating the elements of the arrays, where we introduce the indices like ix, iy","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# the pressure update using the element-wise arithmetic operations\nPf     .-= ((qDx[2:end, :] - qDx[1:end-1, :]).* _dx .+ (qDy[:, 2:end] - qDy[:, 1:end-1]).* _dy).* _β_dτ_D","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 3: Remove the julia functions like diff(A, dims=1) and use the indices ix, iy instead to \"manually\" compute the differences. Another possibility is to use the macros of the ParallelStencil package by @d_xa, @d_ya etc","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"# we manually implemented the macros\nmacro d_xa(A)  esc(:( $A[ix+1,iy]-$A[ix,iy] )) end\nmacro d_ya(A)  esc(:( $A[ix,iy+1]-$A[ix,iy] )) end\n\n# and use them for the loop version of differences calculation\nPf[ix,iy]     -= (@d_xa(qDx) * _dx + @d_ya(qDy)* _dy) * _β_dτ_D\n","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"STEP 4: After verifying the correctness of the bounds to be iterated on, add the macro @inbounds at the needed places\nSTEP 5: Move the loops into a compute kernel in the following forms","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"function compute_Pf!(Pf,...)\n    nx, ny = size(Pf)\n    ...\n    return nothing\nend","category":"page"},{"location":"performance/#Parallelizing-using-ParallelStencil.jl","page":"Performance","title":"Parallelizing using ParallelStencil.jl","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"For the macros that can be used, check the FiniteDifferences.jl","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"\nusing Printf, LazyArrays, Plots, BenchmarkTools\nusing JLD  # for storing testing data\n\n\n@views av1(A) = 0.5.*(A[1:end-1].+A[2:end])\n@views avx(A) = 0.5.*(A[1:end-1,:].+A[2:end,:])\n@views avy(A) = 0.5.*(A[:,1:end-1].+A[:,2:end])\n\n\nmacro d_xa(A)  esc(:( $A[ix+1,iy]-$A[ix,iy] )) end\nmacro d_ya(A)  esc(:( $A[ix,iy+1]-$A[ix,iy] )) end\n\n\n\n# Darcy's flux update\nfunction compute_flux_darcy!(Pf, T, qDx, qDy, _dx, _dy, k_ηf, αρgx, αρgy, _1_θ_dτ_D)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny\n        for ix = 1:nx-1\n            # qDx[2:end-1,:] .-= (qDx[2:end-1,:] .+ k_ηf.*((Pf[2:end,:] .- Pf[1:end-1, :]) .* _dx .- αρgx.*avx(T))).* _1_θ_dτ_D\n            qDx[ix+1,iy] -= (qDx[ix+1,iy] + k_ηf * (@d_xa(Pf) * _dx - αρgx *  0.5 * (T[ix,iy] + T[ix+1,iy]))) * _1_θ_dτ_D\n            \n        end\n    end\n    \n    for iy = 1:ny-1\n        for ix = 1:nx\n            # qDy[:,2:end-1] .-= (qDy[:,2:end-1] .+ k_ηf.*((Pf[:, 2:end] .- Pf[:, 1:end-1]) .* _dy .- αρgy.*avy(T))).* _1_θ_dτ_D\n            qDy[ix,iy+1] -= (qDy[ix,iy+1] + k_ηf * (@d_ya(Pf) * _dy - αρgy * 0.5 * (T[ix, iy] + T[ix, iy+1]))) * _1_θ_dτ_D\n        end\n    end\n\nend\n\n\n# pressure update\nfunction compute_Pf!(Pf, qDx, qDy, _dx, _dy, _β_dτ_D)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny\n        for ix = 1:nx\n            # Pf     .-= ((qDx[2:end, :] - qDx[1:end-1, :]).* _dx .+ (qDy[:, 2:end] - qDy[:, 1:end-1]).* _dy).* _β_dτ_D\n            @inbounds Pf[ix,iy]     -= (@d_xa(qDx) * _dx + @d_ya(qDy)* _dy) * _β_dτ_D\n        end\n    end\n\n    return nothing\nend\n\n\nfunction compute_flux_temp!(Pf, T, qTx, qTy, _dx, _dy, λ_ρCp, _1_θ_dτ_T)\n    nx, ny = size(Pf)\n\n    for iy = 1:ny-2\n        for ix = 1:nx-1\n            # qTx            .-= (qTx .+ λ_ρCp.*(Diff(T[:,2:end-1],dims=1)./dx))./(1.0 + θ_dτ_T)\n            qTx[ix,iy]  -= (qTx[ix,iy] + λ_ρCp*(@d_xa(T[:,2:end-1])* _dx)) * _1_θ_dτ_T                    \n        end\n    end\n    \n    for iy = 1:ny-1\n        for ix = 1:nx-2\n            # qTy            .-= (qTy .+ λ_ρCp.*(Diff(T[2:end-1,:],dims=2)./dy))./(1.0 + θ_dτ_T)\n            qTy[ix,iy]  -= (qTy[ix,iy] + λ_ρCp*(@d_ya(T[2:end-1,:])* _dy)) * _1_θ_dτ_T\n        end\n    end\n\nend\n\n\n\nfunction compute_T!(T, dTdt, qTx, qTy, _dx, _dy, _dt_β_dτ_T)\n    nx, ny = size(T)\n\n    for iy = 1:ny-2\n        for ix = 1:nx-2\n            # T[2:end-1,2:end-1] .-= (dTdt .+ @d_xa(qTx).* _dx .+ @d_ya(qTy).* _dy).* _dt_β_dτ_T\n            T[ix+1,iy+1] -= (dTdt[ix,iy] + @d_xa(qTx)* _dx + @d_ya(qTy)* _dy)* _dt_β_dτ_T                    \n        end\n    end\nend\n\n\n\n@views function porous_convection_2D_xpu(ny_, nt_; do_visu=false, do_check=true, test=true)\n    # physics\n    lx,ly       = 40., 20.\n    k_ηf        = 1.0\n    αρgx,αρgy   = 0.0,1.0\n    αρg         = sqrt(αρgx^2+αρgy^2)\n    ΔT          = 200.0\n    ϕ           = 0.1\n    Ra          = 1000                    # changed from 100\n    λ_ρCp       = 1/Ra*(αρg*k_ηf*ΔT*ly/ϕ) # Ra = αρg*k_ηf*ΔT*ly/λ_ρCp/ϕ\n  \n    # numerics\n    ny          = ny_                     # ceil(Int,nx*ly/lx)\n    nx          = 2 * (ny+1) - 1          # 127\n    nt          = nt_                     # 500\n    re_D        = 4π\n    cfl         = 1.0/sqrt(2.1)\n    maxiter     = 10max(nx,ny)\n    ϵtol        = 1e-6\n    nvis        = 20\n    ncheck      = ceil(max(nx,ny)) # ceil(0.25max(nx,ny))\n  \n    # preprocessing\n    dx,dy       = lx/nx,ly/ny\n    xn,yn       = LinRange(-lx/2,lx/2,nx+1),LinRange(-ly,0,ny+1)\n    xc,yc       = av1(xn),av1(yn)\n    θ_dτ_D      = max(lx,ly)/re_D/cfl/min(dx,dy)\n    β_dτ_D      = (re_D*k_ηf)/(cfl*min(dx,dy)*max(lx,ly))\n   \n    # hpc value precomputation\n    _dx, _dy    = 1. /dx, 1. /dy\n    _ϕ          = 1. / ϕ\n    _1_θ_dτ_D   = 1 ./(1.0 + θ_dτ_D)\n    _β_dτ_D     = 1. /β_dτ_D\n\n\n    # array initialization\n    Pf          = zeros(nx,ny)\n    r_Pf        = zeros(nx,ny)\n    qDx,qDy     = zeros(nx+1,ny),zeros(nx,ny+1)\n    qDx_c,qDy_c = zeros(nx,ny),zeros(nx,ny)\n    qDmag       = zeros(nx,ny)     \n    T           = @. ΔT*exp(-xc^2 - (yc'+ly/2)^2); T[:,1] .= ΔT/2; T[:,end] .= -ΔT/2\n    T_old       = copy(T)\n    dTdt        = zeros(nx-2,ny-2)\n    r_T         = zeros(nx-2,ny-2)\n    qTx         = zeros(nx-1,ny-2)\n    qTy         = zeros(nx-2,ny-1)\n   \n    st          = ceil(Int,nx/25)\n    Xc, Yc      = [x for x=xc, y=yc], [y for x=xc,y=yc]\n    Xp, Yp      = Xc[1:st:end,1:st:end], Yc[1:st:end,1:st:end]\n\n    # visu\n    if do_visu\n        # needed parameters for plotting\n\n        # plotting environment\n        ENV[\"GKSwstype\"]=\"nul\"\n        if isdir(\"viz_out\")==false mkdir(\"viz_out\") end\n        loadpath = \"viz_out/\"; anim = Animation(loadpath,String[])\n        println(\"Animation directory: $(anim.dir)\")\n        iframe = 0\n    end\n\n\n\n    # action\n    t_tic = 0.0; niter = 0\n    for it = 1:nt\n        T_old .= T\n\n        # time step\n        dt = if it == 1 \n            0.1*min(dx,dy)/(αρg*ΔT*k_ηf)\n        else\n            min(5.0*min(dx,dy)/(αρg*ΔT*k_ηf),ϕ*min(dx/maximum(abs.(qDx)), dy/maximum(abs.(qDy)))/2.1)\n        end\n\n        _dt = 1. /dt   # precomputation\n        \n        \n        re_T    = π + sqrt(π^2 + ly^2/λ_ρCp * _dt)\n        θ_dτ_T  = max(lx,ly)/re_T/cfl/min(dx,dy)\n        β_dτ_T  = (re_T*λ_ρCp)/(cfl*min(dx,dy)*max(lx,ly))\n        \n        _1_θ_dτ_T   = 1 ./ (1.0 + θ_dτ_T)\n        _dt_β_dτ_T  = 1 ./(_dt + β_dτ_T) # precomputation\n\n        # iteration loop\n        iter = 1; err_D = 2ϵtol; err_T = 2ϵtol\n        while max(err_D,err_T) >= ϵtol && iter <= maxiter\n            if (it==1 && iter == 11) t_tic = Base.time(); niter=0 end\n\n            # hydro            \n            compute_flux_darcy!(Pf, T, qDx, qDy, _dx, _dy, k_ηf, αρgx, αρgy, _1_θ_dτ_D)\n            compute_Pf!(Pf, qDx, qDy, _dx, _dy, _β_dτ_D)\n            \n            # thermo\n            compute_flux_temp!(Pf, T, qTx, qTy, _dx, _dy, λ_ρCp, _1_θ_dτ_T)\n            #     dTdt        = zeros(nx-2,ny-2)\n            \n\n            dTdt           .= (T[2:end-1,2:end-1] .- T_old[2:end-1,2:end-1]).* _dt .+\n                                (max.(qDx[2:end-2,2:end-1],0.0).*Diff(T[1:end-1,2:end-1],dims=1).* _dx .+\n                                 min.(qDx[3:end-1,2:end-1],0.0).*Diff(T[2:end  ,2:end-1],dims=1).* _dx .+\n                                 max.(qDy[2:end-1,2:end-2],0.0).*Diff(T[2:end-1,1:end-1],dims=2).* _dy .+\n                                 min.(qDy[2:end-1,3:end-1],0.0).*Diff(T[2:end-1,2:end  ],dims=2).* _dy).* _ϕ\n\n            \n            # for iy = 1:ny-2\n            #     for ix = 1:nx-2\n            #         dTdt[ix,iy]           = (T[ix+1,iy+1] - T_old[ix+1,iy+1]) * _dt +\n            #         (max(qDx[2:end-2,2:end-1],0.0) * @d_xa(T[1:end-1,2:end-1]) * _dx  +\n            #          min(qDx[3:end-1,2:end-1],0.0) * @d_xa(T[2:end  ,2:end-1]) * _dx  +\n            #          max(qDy[2:end-1,2:end-2],0.0) * @d_ya(T[2:end-1,1:end-1]) * _dy  +\n            #          min(qDy[2:end-1,3:end-1],0.0) * @d_ya(T[2:end-1,2:end  ]) * _dy) * _ϕ\n\n            #     end\n            # end\n            \n            compute_T!(T, dTdt, qTx, qTy, _dx, _dy, _dt_β_dτ_T)\n\n\n            # TODO: add the boundary condition kernel afterwards\n            # Boundary condition\n            T[[1,end],:]        .= T[[2,end-1],:]\n\n\n            if do_check && iter % ncheck == 0\n                r_Pf  .= Diff(qDx,dims=1).* _dx .+ Diff(qDy,dims=2).* _dy\n                r_T   .= dTdt .+ Diff(qTx,dims=1).* _dx .+ Diff(qTy,dims=2).* _dy\n                err_D  = maximum(abs.(r_Pf))\n                err_T  = maximum(abs.(r_T))\n                # @printf(\"  iter/nx=%.1f, err_D=%1.3e, err_T=%1.3e\\n\",iter/nx,err_D,err_T)\n            end\n            iter += 1; niter += 1\n        end\n        # @printf(\"it = %d, iter/nx=%.1f, err_D=%1.3e, err_T=%1.3e\\n\",it,iter/nx,err_D,err_T)\n\n        if it % nvis == 0\n            qDx_c .= avx(qDx)\n            qDy_c .= avy(qDy)\n            qDmag .= sqrt.(qDx_c.^2 .+ qDy_c.^2)\n            qDx_c ./= qDmag\n            qDy_c ./= qDmag\n            qDx_p = qDx_c[1:st:end,1:st:end]\n            qDy_p = qDy_c[1:st:end,1:st:end]\n            \n\n            # visualisation\n            if do_visu\n                heatmap(xc,yc,T';xlims=(xc[1],xc[end]),ylims=(yc[1],yc[end]),aspect_ratio=1,c=:turbo)\n                png(quiver!(Xp[:], Yp[:], quiver=(qDx_p[:], qDy_p[:]), lw=0.5, c=:black),\n                    @sprintf(\"viz_out/porous2D_%04d.png\",iframe+=1))\n            end\n        end\n\n    end\n\n\n    t_toc = Base.time() - t_tic\n    # FIXME: change the expression to compute the effective memory throughput!\n    A_eff = (3 * 2) / 1e9 * nx * ny * sizeof(Float64)  # Effective main memory access per iteration [GB]\n    t_it  = t_toc / niter                              # Execution time per iteration [s]\n    T_eff = A_eff / t_it                               # Effective memory throughput [GB/s]\n    \n    @printf(\"Time = %1.3f sec, T_eff = %1.3f GB/s \\n\", t_toc, T_eff)\n\n\n    if test == true\n        save(\"../test/qDx_p_ref_30_2D.jld\", \"data\", qDx_c[1:st:end,1:st:end])  # store case for reference testing\n        save(\"../test/qDy_p_ref_30_2D.jld\", \"data\", qDy_c[1:st:end,1:st:end])\n    end\n    \n    # Return qDx_p and qDy_p at final time\n    return [qDx_c[1:st:end,1:st:end], qDy_c[1:st:end,1:st:end]]   \nend\n\n\n\nif isinteractive()\n    porous_convection_2D_xpu(63, 500; do_visu=false, do_check=true,test=false)  # ny = 63\nend\n\n\n","category":"page"},{"location":"dispersion-analysis/#Dispersion-Analysis","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"","category":"section"},{"location":"dispersion-analysis/","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"Using the tools from dispersion analysis, we can analyze the number of iterations required to reach convergence given equations prescribing a physical process.","category":"page"},{"location":"dispersion-analysis/#Numerical-dispersion","page":"Dispersion Analysis","title":"Numerical dispersion","text":"","category":"section"},{"location":"dispersion-analysis/","page":"Dispersion Analysis","title":"Dispersion Analysis","text":"Numerical dispersion: a difficulty with computer simulations of continua (such as fluids) wherein the simulated medium exhibits a higher dispersivity than the true medium. wikipedia","category":"page"},{"location":"timeline/#Timeline","page":"Time line","title":"Timeline","text":"","category":"section"},{"location":"timeline/","page":"Time line","title":"Time line","text":"This is a small timeline of the project development","category":"page"},{"location":"timeline/","page":"Time line","title":"Time line","text":"Datum Content Current goals / Todos\nOct. 25 overview of the JustRelax.jl package, setting goals for the julia course roadmap is provided via hackmd\nNov. 28 Meeting settle the repository structure, current goal focuses on the reproducing the 2D porosity wave benchmark, the implementation of the compressible term and the fluid injection benchmark. Using const PTArray in MetaHydroMech.jl to avoid type instabilities\nNov. 29 Julia course project week 1 separated the boundary condition update routines into the src/boundaryconditions, debugging for the CUDA-aware MPI on RACKlette cluster at CSCS (yet failed).\nDec. 6 Julia course project week 2 Final aim of the course is to migrate the code to 3D\nDec. 8 Meeting CUDA-aware MPI works now by switching mpi implementation used from mpich to openmpi\nDec. 11 Update Compressibility terms added for mass conservation, reliability needs to be verified\nDec. 13 Julia course project week 3 Compressibility for the mass conservation equation seems visually correct. Next step is to use implicit time stepping scheme and use the newest damping terms such that the augmented system is accelerated as in the damped wave equation case\nDec. 16 Meeting Same content as in the course of this week, next step after the course would be to add the inertia term in the momentum equation, which recovers the NS equation\nDec. 17 Update Huge changes to the repository structure, now the fundamental conservation laws are included under src/equations, current aim is both the theory study and some setup for further benchmarks\nDec. 18 - 28 Liteature study for the PT method (MOL approach, general study for the iterative methods, timestepping schemes) working on a final report for the course project\nDec. 29 project report deadline for the course 101-0250-00L ","category":"page"},{"location":"iteration-parameters/#Iteration-Parameters","page":"Iteration Parameters","title":"Iteration Parameters","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The choice of the iteration parameters are essential for the accelerated PT method as the method is highly sensitive to it.","category":"page"},{"location":"iteration-parameters/#Choice-of-iteration-parameters","page":"Iteration Parameters","title":"Choice of iteration parameters","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Generally, the values of the iteration parameters are associated with the maximum eigenvalue of the stiffness matrix.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The optimal iteration parameters for a variety of basic physical processes can be determined analytically but for most of the practical problems the eigenvalue problem needs to be solved.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"For the eigenvalue problem see more about its numerical aspects here.","category":"page"},{"location":"iteration-parameters/#Factor-1:-Choice-of-the-B.C.","page":"Iteration Parameters","title":"Factor 1:  Choice of the B.C.","text":"","category":"section"},{"location":"iteration-parameters/#Factor-2:-Numerical-stability-restriction","page":"Iteration Parameters","title":"Factor 2:  Numerical stability restriction","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"for explicit time integration, the size of the timesteps is upper-bounded","category":"page"},{"location":"iteration-parameters/#Case-studies","page":"Iteration Parameters","title":"Case studies","text":"","category":"section"},{"location":"iteration-parameters/#Physical-processes","page":"Iteration Parameters","title":"Physical processes","text":"","category":"section"},{"location":"iteration-parameters/#).-Diffusion","page":"Iteration Parameters","title":"1). Diffusion","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"rho fracpartial Hpartial t = -nabla_k q_k","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"q_i = -D nabla_k H i = 1 n_d","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Or by plugging the second equation into the first one we obtained a single equation for describing the diffusive process.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"rho fracpartial Hpartial t = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"H ↔ some physical quantity\nD ↔ diffusion coefficient \nρ ↔ proportionality coefficient\nt ↔ physical time","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The stationary diffuion process is given by the above equation when fracpartial Hpartial trightarrow 0","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"0 = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/#Applying-PT-method","page":"Iteration Parameters","title":"Applying PT method","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"For the accelerated PT method we do the following:","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 1: add the inertia term theta_r fracpartial q_ipartial tau to the LHS of the first equation\nSTEP 2: plug the obtained equation from step 1 into the equation 2 to obtain the damped wave equation.\nPDE type switch from parabolic to hyperbolic\ndescribes also wave propagation","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"tilderho theta_r fracpartial^2 Hpartial t^2 + tilderho fracpartial Hpartial tau = nabla_k (D nabla_k H)","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 3: find the optimal Reynolds number\nRe = fractilderhoV_p LD\n, where V_p = sqrtfracDtilderho theta_r is the finite speed of the information signal of the wave propagation.\nThis can be done by the dispersion analysis, the optimal value of Re in this case is Re_textopt = 2 pi","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 4: obtain the optimal parameters of tilderho theta_r using the optimal Reynolds number \nGenerally: \"Low Re ⇒ flows tend to be laminar\" and \"High Re ⇒ flows tend to be turbulent\"","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"tilderho = Re fracDtildeVL","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"theta_r = fracDtilderho tildeV^2 = fracLRe tildeV","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Here we need to solve for V_p = tildeV, where tildeV = fractildeCDelta xDelta tau is the numerical velocity we just introduced. Note that tildeC approx 095 C is used here, which is an emperically determined parameter deduced from numerical experiments.","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"In case D = D(x_k) is not constant, we need to determine its values locally to each grid point. For particularly discontinuous distribution of D, taking a local maximum of D between two neighbouring grid cells for determining the iteration parameters shall be sufficient. Räss et al ","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"STEP 5: perform explicit time stepping","category":"page"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"Restriction for the size of the pseudo timestep damped wave equation: Delta tau leq fracCV_p Delta x, where Delta x = fracLn_x, value of the non-dimensional number C is determined for the linearised problem (von Neumann stability analysis)","category":"page"},{"location":"iteration-parameters/#Results","page":"Iteration Parameters","title":"Results","text":"","category":"section"},{"location":"iteration-parameters/","page":"Iteration Parameters","title":"Iteration Parameters","text":"The number of iterations required for the method to converge is linearly dependent on the numrical grid resolution n_x","category":"page"},{"location":"justrelax-Miniapps/#Miniapps","page":"Miniapps","title":"Miniapps","text":"","category":"section"},{"location":"justrelax-Miniapps/#Stages","page":"Miniapps","title":"7 Stages","text":"","category":"section"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"In the following section we introduce the structure of the main function of an \"Application\" code","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"Quantities needed to describe \"where the problem lives\", in terms of (parallel) topology\nInitialize tools which can represent this domain concretely in parallel (IGG here, could be PETSc/DM)\nConcrete representations of data and population of values\nIncludes information on embedding/coordinates\nTools, dependent on the data representation, to actually solve a particular physical problem (here JustRelax.jl, but could be PETSc's SNES)\nNote that here, the physical timestepping scheme is baked into this \"physical problem\"\nAnalysis and output which depends on the details of the solver\n\"Application\" Analysis and output which does not depend on the details of the solver\nFinalization/Cleanup","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"In a real application, steps 4., 5., and 6. will likely be repeated multiple times and be interspersed with other logic (e.g. a particle advection step).","category":"page"},{"location":"justrelax-Miniapps/","page":"Miniapps","title":"Miniapps","text":"Note: CompGrids.jl combines 1. 2., and part of 3. (coordinates, and the identity of the fields)","category":"page"},{"location":"benchmark-fluid-injection/#Fluid-Injection-Benchmark-(BP1)","page":"Fluid injection","title":"Fluid Injection Benchmark (BP1)","text":"","category":"section"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"We reproduced the fluid injection benchmark (BP1) in a 2D-strike slip fault as in Luca et al. 2022. The benchmark serves to test the solid-fluid interaction in our coupled physical system.","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"In this simple benchmark our solver consists of the fully compressible mass conservation equations for both solid and fluid, and momentum equations for both solid and fluid neglecting inertia effects.","category":"page"},{"location":"benchmark-fluid-injection/#Accurate-numerical-solution","page":"Fluid injection","title":"Accurate numerical solution","text":"","category":"section"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"Using the new damping scheme for the stokes equation while keeping the same formulation for fluid mass and momentum equations, we can achieve a highly accurate numerical solution against the analytical solution as in Viesca 2021.","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"We used following parameters in the benchmark performed, which were kept identical for the analytical and the numerical solution. ","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"    P₀  = 5e6         # [Pa] initial pore pressure                   p(x,0)    = P₀ \n    Δpf = 5e6         # [Pa] injection proceeds at constant pressure p(0, t>0) = Δp\n    ηf  = 1e-3        # [Pa·s] viscosity of the permeating fluid\n    kᵩ  = 1e-15       # [m²]   Darcy permeability of the layer    (table 1 value) -> calcuated from kᵩ = k* (φ)\n    \n    # calculated from values in table 1 with βs = 2.5e-11, βf = 4.0e-10 (see Dal Zilio et al. 2022)\n    βd  = 2.5555555555555557e-11   # drained compressibility of the porous medium\n","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"(Image: fluid injection benchmark)","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"The physical time step size was selected to be Δt = 5 (s). Our numerical solution identically overlap with the analytical solution, at nx = 1001 grid points which we set along the fault.","category":"page"},{"location":"benchmark-fluid-injection/#Animation","page":"Fluid injection","title":"Animation","text":"","category":"section"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"We also provide an animation of the same benchmark run.","category":"page"},{"location":"benchmark-fluid-injection/","page":"Fluid injection","title":"Fluid injection","text":"(Image: fluid injection benchmark)","category":"page"},{"location":"justrelax-modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"First phase for Julia's course:","category":"page"},{"location":"roadmap/#Preparation","page":"Roadmap","title":"Preparation","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ x ] Re-run the code of Sidney and make sure it runs fine\n[ x ] Generate some figures\n[ x ] Add comments on the code where you have questions or something is unclear\n[ x ] Try to change the setup and try to reproduce the porosity wave benchmark as in Raess et al.","category":"page"},{"location":"roadmap/#Implementation","page":"Roadmap","title":"Implementation","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ x ] Add compressibility terms to two-phase flow equations\n[   ] Reproduce fluid injection 2D benchmark in Luca et al. 2022","category":"page"},{"location":"roadmap/#Further-goals","page":"Roadmap","title":"Further goals","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"[ ] Add inertial term to Stokes equations\n[ ] Further Benchmark\n[ ] Move to 3D","category":"page"},{"location":"von-neumann-stability-analysis/#Von-Neumann-Stability-Analysis","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"","category":"section"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"also called as Fourier stability analysis\na procesure used to check the stability of FD schemes when applied to linear PDEs\nbased on the Fourier decomposition of numerical error","category":"page"},{"location":"von-neumann-stability-analysis/#Example-1:-Upper-bound-for-the-\\Delta-\\tau-in-explicit-time-stepping-scheme","page":"Von Neumann Stability Analysis","title":"Example 1: Upper-bound for the Delta tau in explicit time stepping scheme","text":"","category":"section"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"For the damped wave equation when we want to solve it using the PT method, we need to hold to restrictions for parameters if the explicit time stepping scheme is used.","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"The upper-bound is given as ","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"Delta tau leq fracCV_p Delta x","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"Where the non-dimensional number C approx frac1sqrtn_d can be determined using Von Neumann stability analysis, where n_d is the number of spatial dimensions. (Alkhimenkov et al., 2021)","category":"page"},{"location":"von-neumann-stability-analysis/","page":"Von Neumann Stability Analysis","title":"Von Neumann Stability Analysis","text":"NOTE: for implicit time stepping scheme of the wave equations, the restriction on the time step vanishes, the time step will be determined by the scheme for Darcy's flux. In case also the implicit scheme is used for the Darcy's flux, the whole scheme will be unconditionally syable.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Problem:-CUDA-aware-MPI-does-not-work-on-cluster","page":"Troubleshooting","title":"Problem: CUDA-aware MPI does not work on cluster","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The MPI library we are using is the mpich of version 4.0.2, which was installed using spack, and is cuda-aware. Following is the description of the module.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Status","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[ x ] Resolved ","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":" - fixed by switching to the use of openmpi library instead","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Description","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"For the details see the issue","category":"page"},{"location":"troubleshooting/#Problem:-No-solutions-after-certain-iteration-count","page":"Troubleshooting","title":"Problem:  No solutions after certain iteration count","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Status","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[ x ] Resolved ","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":" - normal behavior to be expected","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Using the 2D Hydro-mechanical solver for small R values, solution cannot be correctly plotted after a certain state has been reached. The solution can be correctly plotted until the 48th frame (included) as followed.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Description","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"R=0.5, t=0.2","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: 2D wave)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Where at the 48th frame the distribution of the parameters looks as followed","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"(Image: 2D wave)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"it = 1138, time = 3.307e-02 sec (@ T_eff = 24.00 GB/s) \nit = 1139, time = 3.316e-02 sec (@ T_eff = 24.00 GB/s) \nit = 1140, time = 3.313e-02 sec (@ T_eff = 24.00 GB/s) \nGKS: Rectangle definition is invalid in routine SET_WINDOW\nGKS: Rectangle definition is invalid in routine CELLARRAY\ninvalid range\nGKS: Rectangle definition is invalid in routine SET_WINDOW\nGKS: Rectangle definition is invalid in routine CELLARRAY","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Then at the frames after the 48th frame it looks identical to the 49th frame. (Image: 2D wave)","category":"page"},{"location":"troubleshooting/#Problem:-Overhead-brought-by-using-MetaHydroMech.jl","page":"Troubleshooting","title":"Problem:  Overhead brought by using MetaHydroMech.jl","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Status","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[x] Resolved       - by calling only one compute!() kernel      - use the const to fix the type instability problem of PTArray","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Description","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Using the same pattern as JustRelax.jl, we added the MetaHydroMech.jl to predefine the environment needed for the use of the ParallelStencil.jl. However this brought us a significant loss in the performance. Before it was around 24 GB/s after the code improvement.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"it = 1, time = 1.653e+00 sec (@ T_eff = 9.00 GB/s) \nit = 2, time = 1.519e-01 sec (@ T_eff = 16.00 GB/s) \nit = 3, time = 3.360e-01 sec (@ T_eff = 12.00 GB/s) \nit = 4, time = 2.038e-01 sec (@ T_eff = 16.00 GB/s) \nit = 5, time = 2.077e-01 sec (@ T_eff = 16.00 GB/s) \nit = 6, time = 2.661e-01 sec (@ T_eff = 15.00 GB/s) \nit = 7, time = 2.399e-01 sec (@ T_eff = 14.00 GB/s) \nit = 8, time = 2.561e-01 sec (@ T_eff = 16.00 GB/s) \nit = 9, time = 2.614e-01 sec (@ T_eff = 16.00 GB/s) \nit = 10, time = 2.914e-01 sec (@ T_eff = 14.00 GB/s) \nit = 11, time = 2.558e-01 sec (@ T_eff = 16.00 GB/s) \nit = 12, time = 2.582e-01 sec (@ T_eff = 16.00 GB/s) \nit = 13, time = 2.649e-01 sec (@ T_eff = 15.00 GB/s) \nit = 14, time = 2.845e-01 sec (@ T_eff = 14.00 GB/s) \nit = 15, time = 2.564e-01 sec (@ T_eff = 16.00 GB/s) \nTest Summary:                              | Pass  Total\nReference test: HydroMech2D_incompressible |    5      5\n     Testing HydroMech tests passed \n","category":"page"},{"location":"juliageodynamics/#[GeoParams.jl](https://github.com/JuliaGeodynamics/GeoParams.jl.git)-API","page":"JuliaGeodynamics","title":"GeoParams.jl API","text":"","category":"section"},{"location":"juliageodynamics/#Features","page":"JuliaGeodynamics","title":"Features","text":"","category":"section"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"[x] Functors to available creep laws\n[x] Elasticity struct\n[x] Interoperability with ParallelStencil.jl\n[x] compute_viscosity() agnostic to input parameters\n[x] composable custom creep law","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"The following API is created using the docstrings avaliable within the ParallelStencil.jl package, and is included for convinience here for look-up purpose. Please refer to the official repository and ask the creator of the packages if anything is unclear.","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"<!– ","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"CurrentModule = GeoParams","category":"page"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"Modules = [GeoParams]","category":"page"},{"location":"juliageodynamics/#GeoParams.ConstTemp","page":"JuliaGeodynamics","title":"GeoParams.ConstTemp","text":"ConstTemp(T=1000)\n\nSets a constant temperature inside the box\n\nParameters:\n\nT : the value\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.HalfspaceCoolTemp","page":"JuliaGeodynamics","title":"GeoParams.HalfspaceCoolTemp","text":"HalfspaceCoolTemp(Tsurface=0, Tmantle=1350, Age=60, Adiabat=0)\n\nSets a halfspace temperature structure in plate\n\nParameters:\n\nTsurface: surface temperature [C]\nTmantle:  mantle temperature [C]\nAge:      Thermal Age of plate [Myrs]\nAdiabat:  Mantle Adiabat [K/km]\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.LinTemp","page":"JuliaGeodynamics","title":"GeoParams.LinTemp","text":"LinTemp(Ttop=0, Tbot=1000)\n\nSets a linear temperature structure from top to bottom\n\nParameters:\n\nTtop: the value @ the top\nTbot: the value @ the bottom\n\n\n\n\n\n","category":"type"},{"location":"juliageodynamics/#GeoParams.CompTempStruct-Tuple{Any, ConstTemp}","page":"JuliaGeodynamics","title":"GeoParams.CompTempStruct","text":"CompTempStruct(Z, s::AbstractTempStruct)\n\nReturns a temperature vector that matches the coordinate vector and temperature structure that were passed in\n\nParameters:\n\nZ: vector with depth coordinates\ns: Temperature structure (CostTemp, LinTemp, HalfspaceCoolTemp)\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.LithPres-NTuple{6, Any}","page":"JuliaGeodynamics","title":"GeoParams.LithPres","text":"LithPres(MatParam, Phases, ρ, T, dz, g)\n\nIteratively solves a 1D lithostatic pressure profile (compatible with temperature- and pressure-dependent densities)\n\nParameters:\n\nMatParam: a tuple of materials (including the following properties: Phase, Density)\nPhases:   vector with the distribtion of phases\nρ:        density vector for initial guess(can be zeros)\nT:        temperature vector\ndz:       grid spacing\ng:        gravitational accelaration\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.StrengthEnvelopeComp-Union{Tuple{U}, Tuple{N}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct, Any}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N}}, Vector{U}, GeoParams.AbstractTempStruct, Any, Int64}} where {N, U}","page":"JuliaGeodynamics","title":"GeoParams.StrengthEnvelopeComp","text":"StrengthEnvelopeComp(MatParam::NTuple{N, AbstractMaterialParamsStruct}, Thickness::Vector{U}, TempType::AbstractTempStruct=LinTemp(0C, 800C), ε=1e-15/s, nz::Int64=101) where {N, U}\n\nCalculates a 1D strength envelope. Pressure used for Drucker Prager plasticity is lithostatic. To visualize the results in a GUI, use StrengthEnvelopePlot.\n\nParameters:\n\nMatParam:  a tuple of materials (including the following properties: Phase, Density, CreepLaws, Plasticity)\nThickness: a vector listing the thicknesses of the respective layers (should carry units)\nTempType:  the type of temperature profile (ConstTemp(), LinTemp(), HalfspaceCoolTemp())\nε:         background strainrate\nnz:        optional argument controlling the number of points along the profile (default = 101)\n\nExample:\n\njulia> using GLMakie\njulia> MatParam = (SetMaterialParams(Name=\"UC\", Phase=1, Density=ConstantDensity(ρ=2700kg/m^3), CreepLaws = SetDislocationCreep(\"Wet Quartzite | Ueda et al. (2008)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)),\n                   SetMaterialParams(Name=\"MC\", Phase=2, Density=Density=ConstantDensity(ρ=2900kg/m^3), CreepLaws = SetDislocationCreep(\"Plagioclase An75 | Ji and Zhao (1993)\"), Plasticity = DruckerPrager(ϕ=20.0, C=10MPa)),\n                   SetMaterialParams(Name=\"LC\", Phase=3, Density=PT_Density(ρ0=2900kg/m^3, α=3e-5/K, β=1e-10/Pa), CreepLaws = SetDislocationCreep(\"Maryland strong diabase | Mackwell et al. (1998)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)));\njulia> Thickness = [15,10,15]*km;\n\njulia> StrengthEnvelopeComp(MatParam, Thickness, LinTemp(), ε=1e-15/s)\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.StrengthEnvelopePlot-Tuple{}","page":"JuliaGeodynamics","title":"GeoParams.StrengthEnvelopePlot","text":"StrengthEnvelopePlot(MatParam, Thickness; TempType, nz)\n\nRequires GLMakie\n\nCreates a GUI that plots a 1D strength envelope. In the GUI, temperature profile and strain rate can be adjusted. The Drucker-Prager plasticity uses lithostatic pressure.\n\nParameters:\n\nMatParam:  a tuple of materials (including the following properties: Phase, Density, CreepLaws, Plasticity)\nThickness: a vector listing the thicknesses of the respective layers (should carry units)\nTempType:  the type of temperature profile (LinTemp=default, HalfspaceCoolTemp, ConstTemp)\nnz:        optional argument controlling the number of points along the profile (default = 101)\n\nExample:\n\njulia> using GLMakie\njulia> MatParam = (SetMaterialParams(Name=\"UC\", Phase=1, Density=ConstantDensity(ρ=2700kg/m^3), CreepLaws = SetDislocationCreep(\"Wet Quartzite | Ueda et al. (2008)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)),\n                   SetMaterialParams(Name=\"MC\", Phase=2, Density=Density=ConstantDensity(ρ=2900kg/m^3), CreepLaws = SetDislocationCreep(\"Plagioclase An75 | Ji and Zhao (1993)\"), Plasticity = DruckerPrager(ϕ=20.0, C=10MPa)),\n                   SetMaterialParams(Name=\"LC\", Phase=3, Density=PT_Density(ρ0=2900kg/m^3, α=3e-5/K, β=1e-10/Pa), CreepLaws = SetDislocationCreep(\"Maryland strong diabase | Mackwell et al. (1998)\"), Plasticity = DruckerPrager(ϕ=30.0, C=10MPa)));\njulia> Thickness = [15,10,15]*km;\n\njulia> StrengthEnvelopePlot(MatParam, Thickness, LinTemp())\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij!","text":"compute_p_τij!(Txx, Tyy, Txy, Tii, η_vep, P, Exx, Eyy, Exy, P_o, Txx_o, Tyy_o, Txy_o, phase, MatParam, dt)\n\nComputes 2D deviatoric stress components (Txx,Tyy,Txy) and pressure P given deviatoric strainrate components (Exx,Eyy,Exy) and old deviatoric stresses (Txx_o, Tyy_o, Txy_o) and old pressure P_o (only used for viscoelastic cases). Also returned are Tii (second invariant of the deviatoric stress tensor), and η_vep the viscoelastoplastic effective viscosity.  Also required as input is MatParam, the material parameters for every phase and phase, an integer array of size(Exx) that indicates the phase of every point.\n\nThis function assumes that strainrate points are collocated and that Exx,Eyy,Exy are at the same points.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{T, N2}}, T, Any, Tuple{Vararg{T, N2}}, I}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"P,τij, τII = compute_p_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple{N2,T}, P_old::T, args, τij_old::NTuple{3,T}, phase::I)\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a collocated grid case with a single phase phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, T, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Tuple{Vararg{Union{NTuple{4, I}, I}, N2}}}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"τij, τII, η_eff = compute_p_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple, args, τij_old::NTuple, phases::NTuple)\n\nThis computes pressure p and deviatoric stress components τij, their second invariant τII, and effective viscosity η_eff for given deviatoric strainrates εij, old stresses τij_old, phases (integer) for every point and arguments args. It handles staggered grids of various taste\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{N}, Tuple{T}, Tuple{Any, Tuple{Vararg{T, N}}, T, Any, Tuple{Vararg{T, N}}}} where {T, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"p,τij,τII = compute_p_τij(v, εij::NTuple{n,T}, P_old::T, args,  τij_old::NTuple{N,T})\n\nComputes pressure p and deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a case that all points are collocated and we have a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}, T, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij","text":"p, τij, τII = compute_p_τij(v, εij::NTuple{N,Union{T,NTuple{4,T}}}, P_old::T, args, τij_old::NTuple{3,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a staggered grid case with a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_p_τij_stagcenter!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_p_τij_stagcenter!","text":"compute_τij_stagcenter!(Txx, Tyy, Txy, Tii, η_vep,  P, Exx, Eyy, Exyv, P_o, Txx_o, Tyy_o, Txyv_o, phase_center, phase_vertex, MatParam, dt)\n\nUpdates deviatoric stresses on a staggered grid in a centered based manner (averages strainrates/old stresses from vertices -> centers). Take care of the sizes of the input matrixes:\n\nTxx,Tyy,Txy,Tii,P: 2D matrixes of size (nx,ny) which describe updated deviatoric stress components (x,y,xy, 2nd invariant) at the center point\nη_vep: viscoelastoplastic viscosity @ center (nx,ny)\nExx,Eyy,P_o: deviatoric strain rate components & old pressure @ center\nExy: shear strain rate @ vertices (nx+1,ny+1)\nTxx_o, Tyy_o: deviatoric stress normal components of last timestep at center (nx,ny)\nTxy_o: deviatoric stress shear components at vertices (nx+1,ny+1)\nphase_center: integer array with phase at center points (nx,ny)\nphase_vertex: integer array with phase at vertex points (nx+1,ny+1)\nMatParam: material parameter array that includes a CompositeRheology field which specifies the rheology for different phases\ndt: timestep \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{T, N2}}, Any, Tuple{Vararg{T, N2}}, I}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII = compute_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple{N2,T}, args, τij_old::NTuple{3,T}, phase::I)\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a collocated grid case with a single phase phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{I}, Tuple{N2}, Tuple{N1}, Tuple{T}, Tuple{Tuple{Vararg{AbstractMaterialParamsStruct, N1}}, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N2}}, Tuple{Vararg{Union{NTuple{4, I}, I}, N2}}}} where {T, N1, N2, I<:Integer}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII, η_eff = compute_τij(v::NTuple{N1,AbstractMaterialParamsStruct}, εij::NTuple, args, τij_old::NTuple, phases::NTuple)\n\nThis computes deviatoric stress components τij, their second invariant τII, and effective viscosity η_eff for given deviatoric strainrates εij, old stresses τij_old, phases (integer) for every point and arguments args. This handles various staggered grid arrangements; if staggered components are given as NTuple{4,T}, they will be averaged. Note that the phase of all staggered points should be the same.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{N}, Tuple{T}, Tuple{Any, Tuple{Vararg{T, N}}, Any, Tuple{Vararg{T, N}}}} where {T, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij,τII = compute_τij(v, εij::NTuple{n,T}, args, τij_old::NTuple{N,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a case that all points are collocated and we have a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij-Union{Tuple{T}, Tuple{N}, Tuple{Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}, Any, Tuple{Vararg{Union{NTuple{4, T}, T}, N}}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij","text":"τij, τII = compute_τij(v, εij::NTuple{N,Union{T,NTuple{4,T}}}, args, τij_old::NTuple{3,T})\n\nComputes deviatoric stress τij for given deviatoric strain rate εij, old stress τij_old, rheology v and arguments args. This is for a staggered grid case with a single phase. \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.compute_τij_stagcenter!-Union{Tuple{N}, Tuple{I}, Tuple{_T}, Tuple{AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{_T}, AbstractArray{I}, AbstractArray{I}, Tuple{Vararg{AbstractMaterialParamsStruct, N}}, _T}} where {_T<:Number, I<:Integer, N}","page":"JuliaGeodynamics","title":"GeoParams.compute_τij_stagcenter!","text":"compute_τij_stagcenter!(Txx, Tyy, Txy, Tii, η_vep,  Exx, Eyy, Exyv, P, Txx_o, Tyy_o, Txyv_o, phase_center, phase_vertex, MatParam, dt)\n\nUpdates deviatoric stresses on a staggered grid in a centered based manner (averages strainrates/old stresses from vertices -> centers). Take care of the sizes of the input matrixes:\n\nTxx,Tyy,Txy,Tii: 2D matrixes of size (nx,ny) which describe updated deviatoric stress components (x,y,xy, 2nd invariant) at the center point\nη_vep: viscoelastoplastic viscosity @ center (nx,ny)\nExx,Eyy,P: deviatoric strain rate components & pressure @ center \nExy: shear strain rate @ vertices (nx+1,ny+1)\nTxx_o, Tyy_o: deviatoric stress normal components of last timestep at center (nx,ny)\nTxy_o: deviatoric stress shear components at vertices (nx+1,ny+1)\nphase_center: integer array with phase at center points (nx,ny)\nphase_vertex: integer array with phase at vertex points (nx+1,ny+1)\nMatParam: material parameter array that includes a CompositeRheology field which specifies the rheology for different phases\ndt: timestep \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{NTuple{4, T}, NTuple{4, T}, NTuple{4, T}, Tuple{T, T, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Axx::NTuple{4,T}, Ayy::NTuple{4,T}, Azz::NTuple{4,T}, Aij::NTuple{3,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its diagonal components  need to be maped from cell center to cell vertex. Axx, Ayy, and Azz are tuples containinig the diagonal terms of A at the cell centers around the i-th vertex., and Aij is a tuple that contains the off-diagonal components at the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{NTuple{4, T}, NTuple{4, T}, Number}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Axx::NTuple{4,T}, Ayy::NTuple{4,T}, Axy::Number) where {T}\n\nComputes the second invariant of the 2D tensor A when its diagonal components  need to be maped from cell center to cell vertex. Axx, and Ayy are tuples containinig the diagonal terms of A at the cell centers around the i-th vertex., and Axy is the xy component at the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{Tuple{T, T, T}, NTuple{4, T}, NTuple{4, T}, NTuple{4, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Aii::NTuple{3,T}, Ayz::NTuple{4,T}, Axz::NTuple{4,T}, Axy::NTuple{4,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its off-diagonal components  need to be maped from cell center to cell vertex. Aii is a tuple containinig the diagonal terms of A at the i-th vertex, and Ayz, Axz, and Axy are tuples that contain the off-diagonal components of the tensor at the cell centers around the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.second_invariant_staggered-Union{Tuple{T}, Tuple{Tuple{T, T}, NTuple{4, T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.second_invariant_staggered","text":"second_invariant_staggered(Aii::NTuple{2,T}, Axy::NTuple{4,T}) where {T}\n\nComputes the second invariant of the 2D tensor A when its off-diagonal components  need to be maped from cell center to cell vertex.  Aii is a tuple containinig the diagonal terms of A at the i-th vertex, and Axy is a tuple that contains A_xy at the cell centers around the i-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_p_τII_0D!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Vector{T}, Vector{T}, Any, AbstractVector{T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.time_p_τII_0D!","text":"time_p_τII_0D!(P_vec::Vector{T}, τ_vec::Vector{T}, v::CompositeRheology, εII_vec::Vector{T}, εvol_vec::Vector{T}, args, t_vec::AbstractVector{T}) where {T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given shear and volumetric strainrate vectors (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_p_τII_0D-Tuple{Union{Tuple, CompositeRheology, Parallel}, Number, Number, Any}","page":"JuliaGeodynamics","title":"GeoParams.time_p_τII_0D","text":"t_vec, P_vec, τ_vec = time_p_τII_0D(v::CompositeRheology, εII::Number, εvol::Number, args; t=(0.,100.), τ0=0., nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, shear strainrate εII and volumetric strainrate εvol, as well as rheology arguments args. The initial stress τ0, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D!-Union{Tuple{T}, Tuple{N}, Tuple{Array{Tuple{Vararg{T, N}}, 1}, Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Array{Tuple{Vararg{T, N}}, 1}, Any, AbstractVector{T}}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D!","text":"time_τII_0D!(τ_vec::Vector{NTuple{N,T}}, τII_vec::Vector{T}, v::Union{CompositeRheology,Tuple, Parallel}, ε_vec::Vector{NTuple{N,T}}, args, t_vec::AbstractVector{T}; verbose=false) where {N,T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given strainrate tensor (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D!-Union{Tuple{T}, Tuple{Vector{T}, Union{Tuple, CompositeRheology, Parallel}, Vector{T}, Any, AbstractVector{T}}} where T","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D!","text":"time_τII_0D!(τ_vec::Vector{T}, v::CompositeRheology, εII_vec::Vector{T}, args, t_vec::AbstractVector{T}) where {T}\n\nComputes stress-time evolution for a 0D (homogeneous) setup with given strainrate vector (which can vary with time).\n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D-Tuple{Union{Tuple, CompositeRheology, Parallel}, Number, Any}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D","text":"t_vec, τ_vec = time_τII_0D(v::CompositeRheology, εII::Number, args; t=(0.,100.), τ0=0., nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, strainrate εII and rheology arguments args. The initial stress τ0, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/#GeoParams.time_τII_0D-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple, CompositeRheology, Parallel}, Tuple{Vararg{T, N}}, Any}} where {N, T}","page":"JuliaGeodynamics","title":"GeoParams.time_τII_0D","text":"t_vec, τ_vec = time_τII_0D(v::CompositeRheology, ε::NTuple{N,T}, args; t=(0.,100.), τ0=NTuple{N,T}, nt::Int64=100)\n\nThis performs a 0D constant strainrate experiment for a composite rheology structure v, and a given, constant, strainrate tensor ε and rheology arguments args. The initial deviatoric stress tensor τ, the time range t and the number of timesteps nt can be modified \n\n\n\n\n\n","category":"method"},{"location":"juliageodynamics/","page":"JuliaGeodynamics","title":"JuliaGeodynamics","text":"–>","category":"page"},{"location":"computational-earthquake-physics/#Computational-Earthquake-Physics","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"","category":"section"},{"location":"computational-earthquake-physics/#Geodynamics","page":"Computational Earthquake Physics","title":"Geodynamics","text":"","category":"section"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"\"The crucial point that was finally understood by the geological community is that both viscous (i.e., fluid-like) and elastic (i.e., solid-like) behaviour is a characteristic of the Earth depending on the time scale of deformation. The Earth’s mantle, which is elastic on a human time scale, is viscous on geological time scales (>10 000 years) and can be strongly internally deformed due to solid-state creep. – (Gerya 2019)\"","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"The dual viscous-elastic behaviour of the Earth can be demonstrated using the \"silly putty\", which jumps up like a rubber ball (acts like solid) when we drop it on the floor for a very short timescale, but demonstrates more fluid-like behaviors in a longer time period (few days/weeks).","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"See demonstration of the visco-elasticity here","category":"page"},{"location":"computational-earthquake-physics/#Rock-rheology","page":"Computational Earthquake Physics","title":"Rock rheology","text":"","category":"section"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Rheology:  the composite physical property characterizing deformation behavior of a material.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Rock rheology:  includes several different deformation mechanisms, and is in general visco-elasto-plastic.  Elastic properties are important to be taken into account on a relatively short time scale (10^4 years) for  fast processes like magma intrusion. On the other hand, at low temperature rocks can be subjected to localized  brittle and plastic deformation.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Followingly is a small summary of different types of rheology. The major difference between them is the composition of the bulk deviatoric strain rate dotepsilon_ij. For example, it is decomposed into 2 respective components for visco-plastic rheology as dotepsilon_ij = dotepsilon_ijtext(viscous) + dotepsilon_ijtext(plastic)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-plastic: a strain rate based formation is more suitable. Simplification by assuming that elastic effects are negligible and can be ignored on the long time scales.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-elastic: a stress-based formulation is more suitable. Viscous and elastic rheological relations are combined under certain physical assumptions. Maxwell visco-elastic rheology is the most commenly used type. Definitions of shear and bulk moduli are modified in the equations. More see section 12.4 in (Gerya 2019)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"visco-elasto-plastic: a stress-based formulation is more suitable. It characterises the non-linear instantaneous response at higher stress levels or temperature","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"poro-elastic: Biot's model and its validity at low stress level and negligible viscous relaxation","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"poro-elasto-plastic: ","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"thermo-hydro-chemico-mechanical (THCM): thermal and chemical couplings to deformation (mechanics)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"NOTE: in general, coupling among processes triggers non-linear interactions that may result in significant and spontaneous localization of flow, heat and deformation.","category":"page"},{"location":"computational-earthquake-physics/#Plastic-rheology","page":"Computational Earthquake Physics","title":"Plastic rheology","text":"","category":"section"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Assumption: Existence of an absolute shear stress limit sigma_textyield for a body and after reaching this limit plastic yielding occurs.","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"(Image: Plastic yielding)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Formulations based on the simplified Griffith theory:","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Case 1: Dry rocks","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"sigma_textyield = begincases sigma_c + gamma_textintP  P  fracsigma_c - sigma_t1-gamma_textint text (confined fractures)  sigma_t + P  P  fracsigma_c - sigma_t1-gamma_textint text (tensile fractures) endcases","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Or more compactly","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"sigma_textyield = max 0 min(sigma_c + gamma_textint P^t sigma_t + gamma_textint P^t)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Case 2: Fluid-bearing rocks","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"sigma_textyield = begincases sigma_c + gamma_textint(P^t-P^f)  (P^t-P^f)  fracsigma_c - sigma_t1-gamma_textint text (confined fractures)  sigma_t + (P^t-P^f)  (P^t-P^f)  fracsigma_c - sigma_t1-gamma_textint text (tensile fractures) endcases","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"where sigma_c and sigma_t are respectively compressive length and tensile length such that 2 leq fracsigma_csigma_t leq 8","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"Or using effective pressure for the formulation","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"sigma_textyield = max 0 min(sigma_c + gamma_textint P_texteff sigma_t + gamma_textint P_texteff)","category":"page"},{"location":"computational-earthquake-physics/","page":"Computational Earthquake Physics","title":"Computational Earthquake Physics","text":"NOTE: Yield point - the point on a stress-strain curve that indicates the limit of elastic behavior and the beginning of plastic behavior wiki","category":"page"},{"location":"3D-hydro-mechanical-solver/#D-Hydro-mechanical-Solver","page":"3D-Hydro-mechanical solver","title":"3D Hydro-mechanical Solver","text":"","category":"section"},{"location":"3D-hydro-mechanical-solver/","page":"3D-Hydro-mechanical solver","title":"3D-Hydro-mechanical solver","text":"under development","category":"page"},{"location":"pseudo-transient-method/#Pseudo-Transient-Method","page":"Pseudo Transient Method","title":"Pseudo-Transient Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The Pseudo-Transient Method (PT method), is an iterative method which is:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"matrix-free\nbuilds on a fixed-point iteration\nupdate of each grid point is local, does not require global reductions\nenables easy-to-develop multi-physics coupling due to its conciseness\nsimilarity between mathematical and discretised code notation","category":"page"},{"location":"pseudo-transient-method/#History","page":"Pseudo Transient Method","title":"History","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1911 - Pioneering work by Richardson </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Richardson proposed an iterative solution approach to PDEs related to dam-engineering calculations. Early developed iterative algorithms are well-suited for early low-memory computers but lack in efficient convergence rates.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1950 - First present of the PT method in the literature (Frankel)</summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The idea of accelerating the convergence by increasing the order of PDE dates back to the work by Frankel (1950). Frankel noted the analogy between the iteration process and transient physics. And the accelarated method was called the second-order Richardson method.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Introduced as an extension of the Richardson and Liebmann methods, with dependency on the previous iterations added.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1965 - The PT method originated as a dynamic-relaxation method (Oter) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was applied for calculating the stresses and displacements in concrete pressure vessels.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1972 - Enhanced convergence rates of the PT methods showed (Young) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was firstly performed on par.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1976 - First introduction in geosciences (Cundall) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method was introduced by Cundall as the Fast Lagranngian Analysis of Continua (FLAC) algorithm","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1993, 1994 - Applications of the FLAC method (Poliakov et al.) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The FLAC method was successfully applied to simulate the Rayleigh–Taylor instability in visco-elastic flow (Poliakov et al. 1993), and the formation of shear bands in rocks (Poliakov et al. 1994).","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1993 - Application in buckling (Ramesh and Krishnamoorthy) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>1999 - Application in form-finding (Barnes) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2009 - Application in failure (Kilic and Madenci) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2011 - FEM community still referenced it as the DR-method (Rezauee-Pajand) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2020 - Review on the accurate estimate of extremal eigenvalues for the Chebyshev's semi-iterative methods (Saad) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"NOTE: second-order or extrapolated methods are also termed semi-iterative.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"<details><summary>2022 - Accelerated pseudo-transient method (Räss et al.) </summary>","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Assessing the robustness and scalability of the accelerated pseudo-transient method Räss et al. (2022)","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"</details>","category":"page"},{"location":"pseudo-transient-method/#Classification-of-the-PT-Method","page":"Pseudo Transient Method","title":"Classification of the PT Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The PT method can be classified differently as the first-order PT method and the accelerated PT method.","category":"page"},{"location":"pseudo-transient-method/#First-order-PT-Method","page":"Pseudo Transient Method","title":"First-order PT Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The first order PT method performs the pseudo-time stepping based on a first-order scheme by introducing the pseudo-transient term in the form of fracpartialpartial tau. A physical property A is updated at each PT iteration, using the current values of pseudo-time steps and residuals.","category":"page"},{"location":"pseudo-transient-method/#Accelerated-PT-Method","page":"Pseudo Transient Method","title":"Accelerated PT Method","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"(Image: DOI) (Image: DOI)","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The accelerated PT method is based on a second-order scheme, where a pseudo-transient term in the form of alpha fracpartial^2partial tau^2 + fracpartialpartial tau is introduced. The name of the method comes from the fact that it can significantly enhance the convergence rates of the algorithm when selecting the appropriate damping parameter α.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Followingly we abstract some important aspects reported in the paper \"Assessing the robustness and scalability of the accelerated pseudo-transient method Räss et al. (2022), in which the accelerated PT method was introduced.","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"It has the following advantages:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Ensures the iteration count to scale linearly with numerical resolution increase","category":"page"},{"location":"pseudo-transient-method/#Application","page":"Pseudo Transient Method","title":"Application","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The method is applicable to:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Strongly nonlinear problems\nshear-banding in a visco-elasto-plastic medium","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"Finding solution of stationary problems\nFinding solution of problems with transient terms\ninvolve both physical time t and pseudo-time tau\nalso called \"dual-time method\" or \"dual time stepping\" (Mandal et al 2011) ","category":"page"},{"location":"pseudo-transient-method/#Derivation","page":"Pseudo Transient Method","title":"Derivation","text":"","category":"section"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"A physically motivated derivation is well-presented . To understand how powerful the PT method is, we cited here a small paragraph from the paper:","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"\"The PT methods build on a physical description of a process. It therefore becomes possible to model strongly nonlinear processes and achieve convergence starting from nearly arbitrary initial conditions.\"","category":"page"},{"location":"pseudo-transient-method/","page":"Pseudo Transient Method","title":"Pseudo Transient Method","text":"The accelerated PT method for elliptic equations is mathematically equivalent to the second-order Richardson rule.","category":"page"},{"location":"justrelax-overview/#[JustRelax.jl](https://github.com/PTsolvers/JustRelax.jl)","page":"Overview","title":"JustRelax.jl","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The JustRelax.jl package exploits the two powerful emerging paradigms in HPC, Massively parallel relaxation-cased solvers and HPC with Julia.","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The package is aimed to provide a reusable, extensible and high-performance framework, so that they may be applied within existing application codes and used to develop new ones. ","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"JustRelax contains solvers which are based on the accelerated pseudo-transient (PT) iterative method. ","category":"page"},{"location":"justrelax-overview/#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"[x] 2D viscous stokes\n[x] 2D visco-elsatic stokes\n[ ] 2D non-Newtonian rheology\n[ ] 2D visco-elasto-plasticity\n[ ] 2D 2-phase flow\n[x] 3D Visco-elastic stokes\n[ ] Add the Zaremba-Jaumann rate of the Cauchy stress\n[ ] Refactor thermal diffusion (2D and 3D)\n[x] Paraview interface for 3D viz with WriteVTK.jl\n[ ] Advection: Particles-in-cell\n[ ] Scalability tests\n[ ] Support for GeoParams.jl (ongoing)\n[ ] I/O","category":"page"},{"location":"justrelax-overview/#Workflow","page":"Overview","title":"Workflow","text":"","category":"section"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The JustRelax.jl package contains the solvers for different geophysical problems modelled using PDEs.","category":"page"},{"location":"justrelax-overview/","page":"Overview","title":"Overview","text":"The package is self-contained and is equipped with the boundary conditions and global computational kernels","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2022 You WuPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"2D-hydro-mechanical-solver/#D-Hydro-mechanical-Solver","page":"2D-Hydro-mechanical solver","title":"2D Hydro-mechanical Solver","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"The solvers in our package aims to solve the two-phase flow equations.","category":"page"},{"location":"2D-hydro-mechanical-solver/#Two-phase-flow-(TPF)-solver","page":"2D-Hydro-mechanical solver","title":"Two-phase flow (TPF) solver","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"Comparing to the Stokes flow, equations for three more unknowns are to be solved which are related to the Darcy flux. Here we assume the constant porosity of the solid.","category":"page"},{"location":"2D-hydro-mechanical-solver/#Case-1:-Incompressible","page":"2D-Hydro-mechanical solver","title":"Case 1: Incompressible","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"no mass transfer between the solid and fluid and vice versa\nused in the current developed code of JustRelax.jl","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"i). Total momentum (solid matrix and fluid)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot underlineunderlinesigma + g rho^t = nabla p^t","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"ii). Fluid momentum","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"v^D = -frack^phieta^f(nabla p^f-rho^fg)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iii). incompressible solid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^s = - fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iv). incompressible fluid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^D = fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE 1: Porosity-dependent permeability is given by k^phi = k^phi_r (fracphiphi_r)^m (frac1- phi1-phi_r)^n","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE 2: Porosity-dependent viscosity is given by eta^phi = K_p fraceta^tphi","category":"page"},{"location":"2D-hydro-mechanical-solver/#Case-2:-Compressible","page":"2D-Hydro-mechanical solver","title":"Case 2: Compressible","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"used in the H-MEC model\nto add the compressible terms for the solid & fluid mass, following changes are made in comparison to the incompressible solver\nprecomputation of parameters: drained bulk modulus Kd, Biot-Willis coefficient ɑ, Skempton coefficient B\nthe residual calculation of the incompressible solver RPt, RPf has additional terms","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"i). Total momentum (solid matrix and fluid)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot underlineunderlinesigma + g rho^t = rho^tfracD^sv^sDt","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"ii). Fluid momentum","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"v^D = -frack^phieta^f(nabla p^f-rho^f(g-fracD^fv^fD t))","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iii). Fully compressible solid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^s = -frac1K^d(fracD^s p^tD t - alpha fracD^f p^fDt) - fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"iv). Fully compressible fluid mass","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"nabla cdot v^D = fracalphaK^d(fracD^s p^tD t - frac1B fracD^f p^fDt) + fracp^t-p^feta^phi(1-phi)","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE:  porosity-dependent permeability","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"k^phi = k^* (fracphi^*phi)^n","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"with reference values abstracted from the Table 1\nreference permeability     ↔    k^* = 10^-16 m^2\nreference porosity         ↔    phi^* = 1 ","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"NOTE:  effective visco-plastic compaction viscosity","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"eta^phi = frac2m1+m fraceta_s(vp)phi =^m=1 fraceta_s(vp)phi","category":"page"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"geometrical factor m = 1 for cylindrical pores\neffective visco-plastic shear viscosity of the solid matrix ↔ eta_s(vp)","category":"page"},{"location":"2D-hydro-mechanical-solver/#Others","page":"2D-Hydro-mechanical solver","title":"Others","text":"","category":"section"},{"location":"2D-hydro-mechanical-solver/","page":"2D-Hydro-mechanical solver","title":"2D-Hydro-mechanical solver","text":"McKenzie (1984)","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"HydroMech.jl in still in its development and is expected to release its first version by the end of Dec. 2022.","category":"page"},{"location":"overview/#Structure","page":"Overview","title":"Structure","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"HydroMech.jl\n├── benchmark        # run scripts for reproducing benchmarks in the paper\n├── CNAME\n├── docs             # documentation and final report\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── scripts          # contains the most current version of the scripts in development\n├── src              # should contain the developed code after verification of the correctness\n└── test             # test/part*.jl ↔ testing scripts","category":"page"},{"location":"overview/#Testing","page":"Overview","title":"Testing","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"unit and reference testing are included within the test folder\ncurrently only the reference test for incompressible TPF solver is availble using the porosity wave benchmark","category":"page"},{"location":"#HydroMech.jl","page":"Home","title":"HydroMech.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Hydro-mechanical solver package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HydroMech.jl was developed during the attendance of the course 101-0250-00L at ETH Zürich, which is designed to be a  module of the PTSolver/JustRelax.jl package. It utilizes the pseudo-transient method for efficiency of the PDEs  solving. It is designed to be able to run on both CPUs and GPUs.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page serves as a tutorial for the use of the HydroMech.jl package. The structure overview of the package is briefly described under the \"overview\" section.","category":"page"},{"location":"tutorial/#Workflow","page":"Tutorial","title":"Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The general workflow when using the HydroMech.jl package consists of:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"i). package environment setup","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ii). problem setup for the specific PDEs to be solved","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iii). selection of the PT solver. All PT solvers are involved by the same name solve!() but with different parameters. The correct one will get selected based on the parameters passed, this is decided by multiple dispatch, a Julia language feature. The solve!() shall be placed within the physical time loop and itself embeds a pseudo-time loop implicitly defined in its source module.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"iv). Post-processing of the data, including the visualization or returning of certain data values which can be utilized for testing purposes","category":"page"},{"location":"tutorial/#Example:-Basic-Workflow","page":"Tutorial","title":"Example: Basic Workflow","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Followingly we are going to illustrate the usage of the solvers through a step-by-step example. Let us create a julia script called Example.jl and follow the instructions to understand the workflow of the HydroMech.jl package. Note that for illustration purpose the following example is NOT a working example, it solely serves as an example which illustrates the workflow.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"STEP 1: include the package and set up the environment needed for the ParallelStencil.jl package. This includes the selection of the device, number type to be used and the dimension of the problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We have to set up the environment accordingly in each script due to the usage of the ParallelStencil.jl package, which requires specification of the modules (ParallelStencil.FiniteDifferences1D, ParallelStencil.FiniteDifferences2D ...). One thing to be noticed is that when one wants to use the Github Action to automatize the workflow, the commited code shall not have :gpu specified for the environment setup. Since currently we cannot perform testing using Github GPU resources and this will result it Github Action failure.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# within the Example.jl script\nusing HydroMech\n\n# setup ParallelStencil.jl environment\nmodel = PS_Setup(:cpu, Float64, 2)\nenvironment!(model)\n\n# you can optionally use some other packages such as Plots.jl etc depending on your needs\n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"STEP 2: Define a function where we solve a desired problem by calling the solver","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\n@views function example_problem()\n   \n   #==================== PROBLEM SETUP =======================#\n   # this depends on the model problem one wants to solve, we recommend to distinguish between the physical and numerical properties\n\n   # MESH\n    nx, ny   = 255, 511\n    mesh     = PTGrid((nx,ny), (lx,ly),(dx,dy))\n\n\n\n    # RHEOLOGY\n    # define concrete values for parameters such as μˢ needed in the wanted rheology\n    # types avaliable to be used can be seen under `src/types/Rheology.jl`\n    ɸ0 = 0.01  \n    #... and define some more variables needed\n\n    rheology = ViscousRheology(μˢ,µᶠ,C,R,λp,k0,ɸ0,nₖ,θ_e,θ_k)\n\n    # TWO PHASE FLOW\n    # define the forces\n    ρfg      = 1.0                     # fluid rho*g\n    ρsg      = 2.0*ρfg                 # solid rho*g\n    ρgBG     = ρfg*ɸ0 + ρsg*(1.0-ɸ0)   #Background density\n    \n\n   # Initial conditions:\n   # the arrays with initial values shall be firstly defined as normal julia arrays\n    𝝫              = ɸ0*ones(nx  ,ny  )\n    𝞰ɸ              = μˢ./𝝫./C\n    𝐤ɸ_µᶠ           = k0.*(𝝫./ɸ0)\n   \n   # we need to then further change the values in the object \"flow\" of accordingly, where we need to wrap the CPU arrays to be capable to be used on both CPU and GPU using the PTArray wrapper\n   # PTArray is a compromise for the both CPU and GPU array usage in the ParallelStencil.jl package, more see MetaHydroMech.jl for details\\\n\n    flow              = TwoPhaseFlow2D(mesh, (ρfg, ρsg, ρgBG))\n    flow.𝝫            = PTArray(𝝫)\n    flow.𝞰ɸ           = PTArray(𝞰ɸ)\n    flow.𝐤ɸ_µᶠ        = PTArray(𝐤ɸ_µᶠ)\n\n\n    # PHYSICS FOR COMPRESSIBILITY\n    µ   = 25.0\n    # ...\n\n    compressibility = Compressibility(mesh, µ, Ks, βs, βf)\n\n\n\n    # PT COEFFICIENT  \n    βₚₜ      = 1.0             # numerical compressibility\n    # ...\n    \n    pt = PTCoeff(OriginalDamping,mesh,μˢ,Vsc,βₚₜ,dampX,dampY,Pfdmp,Pfsc,Ptsc)\n\n\n\n   # Boundary conditions:\n   # here we define a named tuple, this will be passed to the solver in order to specify the directions along which\n   # the boundary conditions shall apply\n    freeslip = (freeslip_x=true, freeslip_y=true)\n\n\n   #==================== PHYSICAL TIMELOOP =======================#\n   # define parameters needed to perform your physical time loop\n    t_tot               = 0.02    # total time\n    t                   = 0.0     # current time\n    it                  = 1       # no. iterations\n\n    while t<t_tot\n\n        # Pseudo-time loop solving\n        solve!(flow, compressibility, rheology, mesh, freeslip, pt,Δt,it)\n\n\n        # Optional\n        # one can also save the partial results or define each frame of a gif-animation here\n\n        # Time\n        dt = dt_red/(1e-10+maximum(abs.(∇V)))\n        t  = t + dt\n        it+=1\n    end\n    \n\n    # Optional\n    # possible post-processing here such as the call of some plotting routines\n\n\n    # return desired values from the flow variable after the solving\n    return Array(flow.Pt - flow.Pf)'\nend\n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"STEP 3: Last step is to call the function we just defined and see if we get the results as expected!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"if isinteractive()\n    example_problem()\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This concludes the main idea of the package usage. For a working example please refer to the PorosityWave2D.jl benchmark which followed the above structure.","category":"page"},{"location":"tutorial/#PT-Solvers","page":"Tutorial","title":"PT Solvers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The core of the HydroMech.jl are the solvers. We saw how one can call different solve!() routines by passing different parameters, currently we can choose between the incompressible and compressible two-phase flow solvers using the following commands.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# an example call to the TPF incompressible solver\nsolve!(flow, rheology, mesh, freeslip, pt, Δt, it)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# an example call to the TPF incompressible solver\nsolve!(flow, compressibility, rheology, mesh, freeslip, pt, Δt, it)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the above examples, the variables such as flow::TwoPhaseFlow2D, rheology::ViscousRheology etc. are of types that are defined under the src/types scripts. The PT solvers essentially call different update routines for the residuals, physical properties (under src/equations) and as well as for the boundary updates (under src/boundaryconditions) in each pseudo-time loop. The selection of the routines to be called is based on the problem we aim to solve. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take a peek at the solve!() routine of the TPF incompressible solver, we focus on the pseudo-time loop within the solver routine. Now one can see the advantages why we added one more layer of the abstraction: due to the massive amount of parameters needed in the original equations. In the current solve!(), we need not to explicitly unpack the variables from the struct, we used the Adapt.jl package in order to allow the use of struct members on GPUs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    while err > ε && iter <= iterMax\n        # timing\n        if (iter==11)  global wtime0 = Base.time()  end\n\n        # involve the incompressible TPF solver\n        @parallel compute_params_∇!(flow.𝞰ɸ, flow.𝐤ɸ_µᶠ, flow.𝞀g, flow.∇V, flow.∇qD, flow.𝝫, flow.Pf, flow.Pt, flow.V.x, flow.V.y, flow.qD.x, flow.qD.y, rheology.μˢ, _C, rheology.R, rheology.λp, rheology.k0, _ɸ0, rheology.nₖ, rheology.θ_e, rheology.θ_k, flow.ρfg, flow.ρsg, flow.ρgBG, _dx, _dy)\n\n        # pressure update from the conservation of mass flow\n        @parallel compute_residual_mass_law!(pt.dτPt, pt.dτPf, flow.R.Pt, flow.R.Pf, flow.𝐤ɸ_µᶠ, flow.∇V, flow.∇qD, flow.Pt, flow.Pf, flow.𝞰ɸ, flow.𝝫, pt.Pfsc, pt.Pfdmp, min_dxy2, _dx, _dy)\n        apply_free_slip!(freeslip, pt.dτPf, nx, ny)\n        @parallel compute_pressure!(flow.Pt, flow.Pf, flow.R.Pt, flow.R.Pf, pt.dτPf, pt.dτPt)\n        @parallel compute_tensor!(flow.𝞃.xx, flow.𝞃.yy, flow.𝞃.xy, flow.V.x, flow.V.y,  flow.∇V, flow.R.Pt, rheology.μˢ, pt.βₚₜ, _dx, _dy)\n\n    \n        # velocity update from the conservation of momentum flow\n        # for both fluid and solid\n        @parallel compute_residual_momentum_law!(flow.R.Vx, flow.R.Vy, pt.dVxdτ, pt.dVydτ, flow.𝞃.xx, flow.𝞃.yy, flow.𝞃.xy, flow.Pt, flow.𝞀g, pt.dampX, pt.dampY, _dx, _dy)\n        @parallel compute_velocity!(flow.V.x, flow.V.y, flow.qD.x, flow.qD.y, pt.dVxdτ, pt.dVydτ, flow.𝐤ɸ_µᶠ, flow.Pf, pt.dτV, flow.ρfg, flow.ρgBG, _dx, _dy)\n        apply_free_slip!(freeslip, flow.V.x, flow.V.y, nx+1, ny+1)\n        apply_free_slip!(freeslip, flow.qD.x, flow.qD.y, nx+1, ny+1)\n    \n        # update the porosity\n        @parallel compute_porosity!(flow.𝝫, flow.𝝫_o, flow.∇V, flow.∇V_o, CN, Δt)\n\n\n\n        # ... error updates\n    end","category":"page"},{"location":"tutorial/#Evolution-Operators","page":"Tutorial","title":"Evolution Operators","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can see a solve!() routine defined in src/solvers as wrapper for many some update kernels which are defined within separate scripts of src/evolution_operators. The idea underlying this design is due to the fact that the core of different problems consisting of PDEs still centers around very few fundamental conservation laws. We thus organize each single-step update (kernel updates) into different scripts and named them as MassConservation.jl, MomentumConservation.jl and EnergyConservation.jl etc.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You may have noticed the naming of certain kernel update routines as compute_residual_mass_law!() and compute_residual_momentum_law!(), these methods reflect exactly the governing equation one aims to solve. For more information about the governing equations for each associated solver please refer to the API of HydroMech.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Besides the residual updates the computation kernels for various physical properties associated with each conservation law also are defined here.","category":"page"},{"location":"hydromech/#HydroMech.jl-API","page":"HydroMech.jl","title":"HydroMech.jl API","text":"","category":"section"},{"location":"hydromech/","page":"HydroMech.jl","title":"HydroMech.jl","text":"CurrentModule = HydroMech","category":"page"},{"location":"hydromech/","page":"HydroMech.jl","title":"HydroMech.jl","text":"Modules = [HydroMech]","category":"page"},{"location":"hydromech/#HydroMech.HydroMech","page":"HydroMech.jl","title":"HydroMech.HydroMech","text":"Main module for HydroMech.jl\n\nA collection of hydro-mechanical solvers for incompressible and compressible 2-phase flow.\n\n\n\n\n\n","category":"module"},{"location":"hydromech/#HydroMech.AbstractFlow","page":"HydroMech.jl","title":"HydroMech.AbstractFlow","text":"AbstractFlow{NDIMS, NVARS} An abstract supertype of specific equations such as the compressible Euler equations. The type parameters encode the number of spatial dimensions (nDim) and the number of primary variables (nVar) of the physics model.\n\nNOTE: formulation borrowed from Trixi.jl, changed from AbstractEquations\n\n\n\n\n\n","category":"type"},{"location":"hydromech/#HydroMech.PTGrid","page":"HydroMech.jl","title":"HydroMech.PTGrid","text":"PTGrid{nDim} A concrete type as subtype of PTMesh abstract type. Encode minimal information on a well-defined tensor-structure grid.\n\n\n\n\n\n","category":"type"},{"location":"hydromech/#HydroMech.PTMesh","page":"HydroMech.jl","title":"HydroMech.PTMesh","text":"PTMesh{nDim} An abstract supertype of specific mesh types such as PTGrid The type parameters encode the number of spatial dimensions (nDim).\n\n\n\n\n\n","category":"type"},{"location":"hydromech/#HydroMech.CompressibleTPF-Tuple{}","page":"HydroMech.jl","title":"HydroMech.CompressibleTPF","text":"CompressibleTPF\n\nThe compressible two-phase flow equations without the inertial term. \n\ni). Total momentum (solid matrix and fluid)\n\nnabla cdot underlineunderlinesigma + g rho^t = 0\n\nii). Fluid momentum\n\nv^D = -frack^phieta^f(nabla p^f-rho^fg)\n\niii). Compressible solid mass\n\nnabla cdot v^s = -frac1K^d(fracD^s p^tD t - alpha fracD^f p^fDt) - fracp^t-p^feta^phi(1-phi)\n\niv). Compressible fluid mass\n\nnabla cdot v^D = fracalphaK^d(fracD^s p^tD t - frac1B fracD^f p^fDt) + fracp^t-p^feta^phi(1-phi)\n\n\n\n\n\n","category":"method"},{"location":"hydromech/#HydroMech.IncompressibleTPF-Tuple{}","page":"HydroMech.jl","title":"HydroMech.IncompressibleTPF","text":"IncompressibleHydroMech\n\nThe incompressible two-phase flow equations without the inertial term. \n\ni). Total momentum (solid matrix and fluid)\n\nnabla cdot underlineunderlinesigma + g rho^t = 0\n\nii). Fluid momentum\n\nv^D = -frack^phimu^f(nabla p^f-rho^fg)\n\niii). Incompressible solid mass\n\nnabla cdot v^s = - fracp^t-p^feta^phi(1-phi)\n\niv). Incompressible fluid mass\n\nnabla cdot v^D = fracp^t-p^feta^phi(1-phi)\n\n\n\n\n\n","category":"method"}]
}
