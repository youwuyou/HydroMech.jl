<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · HydroMech.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="HydroMech.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HydroMech.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Example:-Basic-Workflow"><span>Example: Basic Workflow</span></a></li><li><a class="tocitem" href="#PT-Solvers"><span>PT Solvers</span></a></li><li><a class="tocitem" href="#Evolution-Operators"><span>Evolution Operators</span></a></li></ul></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../2D-hydro-mechanical-solver/">2D-Hydro-mechanical solver</a></li><li><a class="tocitem" href="../3D-hydro-mechanical-solver/">3D-Hydro-mechanical solver</a></li></ul></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../pseudo-transient-method/">Pseudo Transient Method</a></li><li><a class="tocitem" href="../iteration-parameters/">Iteration Parameters</a></li><li><a class="tocitem" href="../computational-earthquake-physics/">Computational Earthquake Physics</a></li></ul></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../benchmark-porosity-wave/">Porosity Wave</a></li><li><a class="tocitem" href="../benchmark-fluid-injection/">Fluid injection</a></li></ul></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><span class="tocitem">Development</span><ul><li><a class="tocitem" href="../roadmap/">Roadmap</a></li><li><a class="tocitem" href="../timeline/">Time line</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../hydromech/">HydroMech.jl</a></li><li><input class="collapse-toggle" id="menuitem-9-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2"><span class="docs-label">PTsolvers/JustRelax.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../justrelax-overview/">Overview</a></li><li><input class="collapse-toggle" id="menuitem-9-2-2" type="checkbox"/><label class="tocitem" for="menuitem-9-2-2"><span class="docs-label">Source code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../justrelax-modules/">Modules</a></li><li><a class="tocitem" href="../justrelax-types/">Types</a></li></ul></li><li><a class="tocitem" href="../justrelax-Miniapps/">Miniapps</a></li><li><a class="tocitem" href="../justrelax-Testing/">Testing</a></li></ul></li><li><a class="tocitem" href="../parallelstencil/">ParallelStencil</a></li><li><a class="tocitem" href="../juliageodynamics/">JuliaGeodynamics</a></li></ul></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/youwuyou/HydroMech.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This page serves as a tutorial for the use of the <code>HydroMech.jl</code> package. The structure overview of the package is briefly described under the &quot;overview&quot; section.</p><h1 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h1><p>The general workflow when using the <code>HydroMech.jl</code> package consists of:</p><p>i). package environment setup</p><p>ii). problem setup for the specific PDEs to be solved</p><p>iii). selection of the PT solver. All PT solvers are involved by the same name <code>solve!()</code> but with different parameters. The correct one will get selected based on the parameters passed, this is decided by multiple dispatch, a Julia language feature. The <code>solve!()</code> shall be placed within the physical time loop and itself embeds a pseudo-time loop implicitly defined in its source module.</p><p>iv). Post-processing of the data, including the visualization or returning of certain data values which can be utilized for testing purposes</p><h2 id="Example:-Basic-Workflow"><a class="docs-heading-anchor" href="#Example:-Basic-Workflow">Example: Basic Workflow</a><a id="Example:-Basic-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Basic-Workflow" title="Permalink"></a></h2><p>Followingly we are going to illustrate the usage of the solvers through a step-by-step example. Let us create a julia script called <code>Example.jl</code> and follow the instructions to understand the workflow of the <code>HydroMech.jl</code> package. Note that for illustration purpose the following example is NOT a working example, it solely serves as an example which illustrates the workflow.</p><ul><li>STEP 1: include the package and set up the environment needed for the <code>ParallelStencil.jl</code> package. This includes the selection of the device, number type to be used and the dimension of the problem.</li></ul><p>We have to set up the environment accordingly in each script due to the usage of the <code>ParallelStencil.jl</code> package, which requires specification of the modules (<code>ParallelStencil.FiniteDifferences1D</code>, <code>ParallelStencil.FiniteDifferences2D</code> ...). One thing to be noticed is that when one wants to use the Github Action to automatize the workflow, the commited code shall not have <code>:gpu</code> specified for the environment setup. Since currently we cannot perform testing using Github GPU resources and this will result it Github Action failure.</p><pre><code class="language-julia hljs"># within the Example.jl script
using HydroMech

# setup ParallelStencil.jl environment
model = PS_Setup(:cpu, Float64, 2)
environment!(model)

# you can optionally use some other packages such as Plots.jl etc depending on your needs
</code></pre><ul><li>STEP 2: Define a function where we solve a desired problem by calling the solver</li></ul><pre><code class="language-julia hljs">
@views function example_problem()
   
   #==================== PROBLEM SETUP =======================#
   # this depends on the model problem one wants to solve, we recommend to distinguish between the physical and numerical properties

   # MESH
    nx, ny   = 255, 511
    mesh     = PTGrid((nx,ny), (lx,ly),(dx,dy))



    # RHEOLOGY
    # define concrete values for parameters such as μˢ needed in the wanted rheology
    # types avaliable to be used can be seen under `src/types/Rheology.jl`
    ɸ0 = 0.01  
    #... and define some more variables needed

    rheology = ViscousRheology(μˢ,µᶠ,C,R,λp,k0,ɸ0,nₖ,θ_e,θ_k)

    # TWO PHASE FLOW
    # define the forces
    ρfg      = 1.0                     # fluid rho*g
    ρsg      = 2.0*ρfg                 # solid rho*g
    ρgBG     = ρfg*ɸ0 + ρsg*(1.0-ɸ0)   #Background density
    

   # Initial conditions:
   # the arrays with initial values shall be firstly defined as normal julia arrays
    𝝫              = ɸ0*ones(nx  ,ny  )
    𝞰ɸ              = μˢ./𝝫./C
    𝐤ɸ_µᶠ           = k0.*(𝝫./ɸ0)
   
   # we need to then further change the values in the object &quot;flow&quot; of accordingly, where we need to wrap the CPU arrays to be capable to be used on both CPU and GPU using the PTArray wrapper
   # PTArray is a compromise for the both CPU and GPU array usage in the ParallelStencil.jl package, more see MetaHydroMech.jl for details\

    flow              = TwoPhaseFlow2D(mesh, (ρfg, ρsg, ρgBG))
    flow.𝝫            = PTArray(𝝫)
    flow.𝞰ɸ           = PTArray(𝞰ɸ)
    flow.𝐤ɸ_µᶠ        = PTArray(𝐤ɸ_µᶠ)


    # PHYSICS FOR COMPRESSIBILITY
    µ   = 25.0
    # ...

    compressibility = Compressibility(mesh, µ, Ks, βs, βf)



    # PT COEFFICIENT  
    βₚₜ      = 1.0             # numerical compressibility
    # ...
    
    pt = PTCoeff(OriginalDamping,mesh,μˢ,Vsc,βₚₜ,dampX,dampY,Pfdmp,Pfsc,Ptsc)



   # Boundary conditions:
   # here we define a named tuple, this will be passed to the solver in order to specify the directions along which
   # the boundary conditions shall apply
    freeslip = (freeslip_x=true, freeslip_y=true)


   #==================== PHYSICAL TIMELOOP =======================#
   # define parameters needed to perform your physical time loop
    t_tot               = 0.02    # total time
    t                   = 0.0     # current time
    it                  = 1       # no. iterations

    while t&lt;t_tot

        # Pseudo-time loop solving
        solve!(flow, compressibility, rheology, mesh, freeslip, pt,Δt,it)


        # Optional
        # one can also save the partial results or define each frame of a gif-animation here

        # Time
        dt = dt_red/(1e-10+maximum(abs.(∇V)))
        t  = t + dt
        it+=1
    end
    

    # Optional
    # possible post-processing here such as the call of some plotting routines


    # return desired values from the flow variable after the solving
    return Array(flow.Pt - flow.Pf)&#39;
end
</code></pre><ul><li>STEP 3: Last step is to call the function we just defined and see if we get the results as expected!</li></ul><pre><code class="language-julia hljs">if isinteractive()
    example_problem()
end</code></pre><p>This concludes the main idea of the package usage. For a working example please refer to the <a href="https://github.com/youwuyou/HydroMech.jl/blob/main/benchmark/incompressible/PorosityWave2D.jl"><code>PorosityWave2D.jl</code> benchmark</a> which followed the above structure.</p><h2 id="PT-Solvers"><a class="docs-heading-anchor" href="#PT-Solvers">PT Solvers</a><a id="PT-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#PT-Solvers" title="Permalink"></a></h2><p>The core of the HydroMech.jl are the <a href="https://github.com/youwuyou/HydroMech.jl/tree/main/src/solvers">solvers</a>. We saw how one can call different <code>solve!()</code> routines by passing different parameters, currently we can choose between the incompressible and compressible two-phase flow solvers using the following commands.</p><pre><code class="language-julia hljs"># an example call to the TPF incompressible solver
solve!(flow, rheology, mesh, freeslip, pt, Δt, it)</code></pre><pre><code class="language-julia hljs"># an example call to the TPF incompressible solver
solve!(flow, compressibility, rheology, mesh, freeslip, pt, Δt, it)</code></pre><p>In the above examples, the variables such as <code>flow::TwoPhaseFlow2D</code>, <code>rheology::ViscousRheology</code> etc. are of types that are defined under the <code>src/types</code> scripts. The PT solvers essentially call different update routines for the residuals, physical properties (under <code>src/equations</code>) and as well as for the boundary updates (under <code>src/boundaryconditions</code>) in each pseudo-time loop. The selection of the routines to be called is based on the problem we aim to solve. </p><p>Let&#39;s take a peek at the <code>solve!()</code> routine of the TPF incompressible solver, we focus on the pseudo-time loop within the solver routine. Now one can see the advantages why we added one more layer of the abstraction: due to the massive amount of parameters needed in the original equations. In the current <code>solve!()</code>, we need not to explicitly unpack the variables from the struct, we used the <code>Adapt.jl</code> package in order to allow the use of struct members on GPUs.</p><pre><code class="language-julia hljs">    while err &gt; ε &amp;&amp; iter &lt;= iterMax
        # timing
        if (iter==11)  global wtime0 = Base.time()  end

        # involve the incompressible TPF solver
        @parallel compute_params_∇!(flow.𝞰ɸ, flow.𝐤ɸ_µᶠ, flow.𝞀g, flow.∇V, flow.∇qD, flow.𝝫, flow.Pf, flow.Pt, flow.V.x, flow.V.y, flow.qD.x, flow.qD.y, rheology.μˢ, _C, rheology.R, rheology.λp, rheology.k0, _ɸ0, rheology.nₖ, rheology.θ_e, rheology.θ_k, flow.ρfg, flow.ρsg, flow.ρgBG, _dx, _dy)

        # pressure update from the conservation of mass flow
        @parallel compute_residual_mass_law!(pt.dτPt, pt.dτPf, flow.R.Pt, flow.R.Pf, flow.𝐤ɸ_µᶠ, flow.∇V, flow.∇qD, flow.Pt, flow.Pf, flow.𝞰ɸ, flow.𝝫, pt.Pfsc, pt.Pfdmp, min_dxy2, _dx, _dy)
        apply_free_slip!(freeslip, pt.dτPf, nx, ny)
        @parallel compute_pressure!(flow.Pt, flow.Pf, flow.R.Pt, flow.R.Pf, pt.dτPf, pt.dτPt)
        @parallel compute_tensor!(flow.𝞃.xx, flow.𝞃.yy, flow.𝞃.xy, flow.V.x, flow.V.y,  flow.∇V, flow.R.Pt, rheology.μˢ, pt.βₚₜ, _dx, _dy)

    
        # velocity update from the conservation of momentum flow
        # for both fluid and solid
        @parallel compute_residual_momentum_law!(flow.R.Vx, flow.R.Vy, pt.dVxdτ, pt.dVydτ, flow.𝞃.xx, flow.𝞃.yy, flow.𝞃.xy, flow.Pt, flow.𝞀g, pt.dampX, pt.dampY, _dx, _dy)
        @parallel compute_velocity!(flow.V.x, flow.V.y, flow.qD.x, flow.qD.y, pt.dVxdτ, pt.dVydτ, flow.𝐤ɸ_µᶠ, flow.Pf, pt.dτV, flow.ρfg, flow.ρgBG, _dx, _dy)
        apply_free_slip!(freeslip, flow.V.x, flow.V.y, nx+1, ny+1)
        apply_free_slip!(freeslip, flow.qD.x, flow.qD.y, nx+1, ny+1)
    
        # update the porosity
        @parallel compute_porosity!(flow.𝝫, flow.𝝫_o, flow.∇V, flow.∇V_o, CN, Δt)



        # ... error updates
    end</code></pre><h2 id="Evolution-Operators"><a class="docs-heading-anchor" href="#Evolution-Operators">Evolution Operators</a><a id="Evolution-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Evolution-Operators" title="Permalink"></a></h2><p>One can see a <code>solve!()</code> routine defined in <code>src/solvers</code> as wrapper for many some update kernels which are defined within separate scripts of <code>src/evolution_operators</code>. The idea underlying this design is due to the fact that the core of different problems consisting of PDEs still centers around very few fundamental conservation laws. We thus organize each single-step update (kernel updates) into different scripts and named them as <code>MassConservation.jl</code>, <code>MomentumConservation.jl</code> and <code>EnergyConservation.jl</code> etc.</p><p>You may have noticed the naming of certain kernel update routines as <code>compute_residual_mass_law!()</code> and <code>compute_residual_momentum_law!()</code>, these methods reflect exactly the governing equation one aims to solve. For more information about the governing equations for each associated solver please refer to the API of HydroMech.</p><p>Besides the residual updates the computation kernels for various physical properties associated with each conservation law also are defined here.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../2D-hydro-mechanical-solver/">2D-Hydro-mechanical solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 8 April 2023 21:48">Saturday 8 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
